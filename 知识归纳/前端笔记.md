#### 1.水平和垂直居中布局的实现方式有哪些？
    1.1 文字垂直居中
        单行文字
            line-height + text-align:center
            
        多行文字
            <div class="box"><p>sdasdasdasdasdasd</p></div>
            
            .box{
                display:table;//转化为表格元素
                text-align:center;
            }
            .box p{
                display:table-ceil;//表格子元素
                vertical-align:middle;
            }
            
    1.2 使用absolute与transform配合实现
    
    1.3 flex布局
        
        display: flex;
        align-items: center;
        justify-content: center;
        
    1.4 absolute与margin
    
        .box{
            position:absolute;
            top:0;
            left: 0;
            right:0;
            bottom:0;
            margin:auto; 
            width:300px;
            height:300px;
            background-color: aquamarine;
        }
        
    1.5 已知物体宽度高度
        
        width: 300px;
        height:300px;
        position: absolute;
        top:50%;
        left:50%;
        margin-top: -150px; //自身高度的一半
        margin-left:-150px;
        
    1.6 inline-block + table-cell + text-align + vertical-align
        .parent{
        	text-align: center;
        	display: table-cell;
        	vertical-align: middle;
        }
        .child{
        	display: inline-block;
        }


#### 2.flex布局的常用属性
    容器属性：
        1.flex-direction决定主轴的方向（即项目的排列方向）
          flex-direction: row | row-reverse | column | column-reverse;
                            左到右|右到左|上到下|下到上
        
        2.flex-wrap定义，如果一条轴线排不下，如何换行
          flex-wrap: nowrap | wrap | wrap-reverse;
                     不换行|换行|倒序换行
                     
        3.flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap
          flex-flow: <flex-direction> || <flex-wrap>;
          
        4.justify-content  定义了项目在主轴上的对齐方式
           justify-content: flex-start | flex-end | center | space-between | space-around;   
                            紧靠开始方向 | 紧靠结束方向 | 居中 | 相邻之间有空隙,前后两个挨着边界 | 每个元素四周都有空隙
        
        5.align-items 属性定义项目在交叉轴上如何对齐。
            align-items: flex-start | flex-end | center | baseline | stretch;
                         对齐主轴开始方向 | 对齐主轴末尾方向 | 居中 | 项目的第一行文字的基线对齐 | 如果项目未设置高度或设为auto，将占满整个容器的高度
                         
        6.align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
            align-content: flex-start | flex-end | center | space-between | space-around | stretch
                           多行贴紧上方 | 多行贴紧下方 | 垂直居中 | 行之间有空隙 | 每行都有空隙 | 轴线占满整个交叉轴
                           
    项目的属性:
        1.order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
        
        2.flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
            如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个
            项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
            
        3.flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
            如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
            如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
            负值对该属性无效。
            
        4.flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
          浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。    
          它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
         
        5. align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。即单独设置align-item属性
                     默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 
            align-self: auto | flex-start | flex-end | center | baseline | stretch; 
            
#### 3.h5新增加了哪些标签？

   header、section、article、aside、nav导航、figure定义媒介内容的分组、figcaption、menu列表或菜单、hgroup标题组、small小号文本、details定义元素的细节、meter定义预定义范围内的度量、progress进度条、video、audio、template、	
   
    <progress id="jindu" max="100" value="0"></progress>进度条

    <meter min="0" max="10" value="4" low="2" high="7">
    其中low和high是范围，当value范围超了话就会显示不同的效果
    
    <hgroup><!--标题组-->
        <h3>标题</h3>
        <h3>标题1</h3>
        <h3>标题2</h3>
        <h3>标题3</h3>
    </hgroup>
    
    <menu>
         <li>定义列表</li>
         <li>定义列表</li>
         <li>定义列表</li>
    </menu>
    
    <figure>
        <figcaption>标题</figcaption><!--配套-->
        <p>标题内容</p>
    </figure>
    
    <aside> 标签定义 article 以外的内容。aside 的内容应该与 article 的内容相关。
 
    section和article的区别

    article元素代表文档、页面或应用程序中独立的、完整的、可以独自被外部引用的内容。
        
    section元素代表网页或者应用程序页面的一个一般的区块。一个section通
    常由内容及标题组成，可以用来描述章节、标签式对话框中的各种标签页、
    论文中带编号的区块。  
         
    section主要用于内容不可脱离上下文，article作为一个完整独立的内容存在。
    article是一个特殊的section标签，比section具有更明确的语义，代表一个独立的、完整的内容块。

    article元素是可以嵌套使用的。
   
   
#### 4.h5新增api
    
    FileReader   通过new FileReader()创建对象，FileReader对象具有以下读取方法
        readAsText(file, encoding):以纯文本的形式读取文件，将读取到的文本保存在result属性中。
        readAsDataURL(file)：读取文件并将文件一数据URI的形式保存在result属性中
        readAsArrayBuffer(file)：读取文件并将一个包含文件内容的ArrayBuffer保存在result属性中。
    
        FileReader对象具有几种监听方法，以下为常用方法    
            reader.progress = function(event){
                if (event.lengthComputable){
                    progress.innerHTML = event.loaded + "/" + event.total;
                }
            }
            reader.load = function(){}
            reader.error = function(){}
    
    
    Web Workers 
        专用Web Worker提供可一个简单的方法使的web内容能够在后台运行脚本。
        一旦worker创建后，它可以向由它的创建者指定的事件监听函数传递消息
        ，这样改worker生成的所有任务就都会接收到这个消息。worker线程能够
        在不干扰UI的情况下执行任务。
        
        所执行的JavaScript代码完全在另一个作用域，与当前网页中的代码不共享作用域
        
        example.html（主页面）
            var myWorker = new Worker("my_task.js");
    
            myWorker.onmessage = function (oEvent) {
              console.log("Worker said : " + oEvent.data);
            };
            
            myWorker.postMessage("ali");
        
        my_task.js(worker)
            postMessage("I\'m working before postMessage(\'ali\').");

            onmessage = function (oEvent) {
              postMessage("Hi " + oEvent.data);
            };
    
    
    history
        h5新增的方法,两种方法都允许我们添加和更新历史记录
        history.pushState()和history.replaeState(); 
        
        使用history.go和history.back方法，popstate事件都会被触发
        window.onpopstate = function(e) {}
        
        
        pushState将当前浏览器的地址栏改为参数url指定的值，但并不会加载它。
    
        
    SVG
        一种使用 XML 描述 2D 图形的语言。SVG 对象的属性发生变化，那么浏览器能够自动重现图形
        
    canvas
        通过 JavaScript 来绘制 2D 图形;
        逐像素进行渲染的;
        其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。
        
    Canvas 与 SVG 的比较
    
        Canvas
            依赖分辨率
            不支持事件处理器
            弱的文本渲染能力
            能够以 .png 或 .jpg 格式保存结果图像
            最适合图像密集型的游戏，其中的许多对象会被频繁重绘
            
        SVG
            不依赖分辨率
            支持事件处理器
            最适合带有大型渲染区域的应用程序（比如谷歌地图）
            复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）
            不适合游戏应用
    
    websocket
    
    geolocation 地理位置
    
    drag和drop拖拽

#### 5.h5新增css3属性
    border边框
        border-radius	边框圆角
        border-shadow	边框阴影
        border-image	边框图片
        background-size	规定背景图片的尺寸
        border-origin	规定背景图片的定位区域
        border-clip	规定背景的绘制区域
        
        
    文本效果(常用)    
        text-shadow：设置文字阴影
        word-wrap：强制换行
        word-break：规定自动换行的处理方法
        
    2/3D转换
        transform：向元素应用2/3D转换
        transition：过渡
        
    动画
        @keyframes规则：
           animation、animation-name、animation-duration等
           
    用户界面(常用)
        box-sizing、resize
        
    css3新增伪类
        ：nth-child()
        
        ：nth-last-child()
        
        ：only-child
        
        ：last-child
        
        ：nth-of-type()
        
        ：only-of-type
        
        ：empty 表示没有子元素包括文本
        
        ：target 这个伪类允许我们选择基于URL的元素，如果这个元素有一个识别器(比如跟着一个#)，那么:target会对使用这个ID识别器的元素增加样式。
        
        ：enabled
        
        ：disabled
        
        ：checked
        
        ：not
        
#### 6.如何区分 HTML 和 HTML5？
        新特性：
        
        拖拽释放(Drag and drop) API
        语义化更好的内容标签（header,nav,footer,aside,article,section）
        音频、视频API(audio,video)
        画布(Canvas) API
        地理(Geolocation) API
        本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
        sessionStorage 的数据在浏览器关闭后自动删除
        表单控件，calendar、date、time、email、url、search
        新的技术webworker, websocket, Geolocation支持HTML5新标签：
        
#### 7.前端跨域的解决方法有哪些？（并对jsonp实现原理简要说明下）
    
    1、 通过jsonp跨域
    
        利用script标签能跨域的特性，jsonp实现跨域的原理是跨域的服务端
        把客户端所需要的数据放进客户端本地的一个js方法里，进行调用，客
        户端在本地的js对返回的数据进行处理。这样就实现了不同域名下的两
        个站点间的交流。
        
        通过script标签请求，将客户端的全局方法作为请求参数传给服务器，
        服务器将数据放入客户端的方法然后返回，返回即调用该方法
    
        jsonp缺点：只能实现get一种请求。
        
    2、 document.domain + iframe跨域
        
        此方案仅限主域相同，子域不同的跨域应用场景。
        
        实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。
        
        1.）父窗口：(http://www.domain.com/a.html)
        
        <iframe id="iframe" src="http://child.domain.com/b.html"></iframe>
        <script>
            document.domain = 'domain.com';
            var user = 'admin';
        </script>
        
        2.）子窗口：(http://child.domain.com/b.html)
        
        <script>
            document.domain = 'domain.com';
            // 获取父窗口中变量
            alert('get js data from parent ---> ' + window.parent.user);
        </script>
    
    3、 location.hash + iframe
    
        实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利
        用iframe的location.hash传值，相同域之间直接js访问来通信。
        
        具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，
        b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。
        
        1.）a.html：(http://www.domain1.com/a.html)
        <iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"></iframe>
        <script>
            var iframe = document.getElementById('iframe');
        
            // 向b.html传hash值
            setTimeout(function() {
                iframe.src = iframe.src + '#user=admin';
            }, 1000);
            
            // 开放给同域c.html的回调方法
            function onCallback(res) {
                alert('data from c.html ---> ' + res);
            }
        </script>
        2.）b.html：(http://www.domain2.com/b.html)
        
        <iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"></iframe>
        <script>
            var iframe = document.getElementById('iframe');
        
            // 监听a.html传来的hash值，再传给c.html
            window.onhashchange = function () {
                iframe.src = iframe.src + location.hash;
            };
        </script>
        3.）c.html：(http://www.domain1.com/c.html)
        
        <script>
            // 监听b.html传来的hash值
            window.onhashchange = function () {
                // 再通过操作同域a.html的js回调，将结果传回
                window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', ''));
            };
        </script>
        
    4、 window.name + iframe跨域
        window.name属性的独特之处：name在不同页面共享，name值在不同的页面（甚至不同域名）
        加载后依旧存在，并且可以支持非常长的 name 值
        
        总结：通过iframe的打开需要传递数据的页面，在iframe设置window.name后关闭，实现数据传递。
        这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。
    
    5、 postMessage跨域
        
        postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，
        它可用于解决以下方面的问题：
            1.只能在两个窗口（iframe）之间交换数据
            2.两个窗口能通信的前提是，一个窗口以iframe的形式存在于另一个窗口，
            或者一个窗口是从另一个窗口通过window.open()或者超链接的形式打开
            的（同样可以用window.opener获取源窗口）
        
        用法：postMessage(data,origin)方法接受两个参数
        
        data： html5规范支持任意基本类型或可复制的对象，但部
        分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
        
        origin： 协议+主机+端口号，也可以设置为"*"，表示可以
        传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。
    
    6、 跨域资源共享（CORS）
        普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，
        前端无须设置，若要带cookie请求：前后端都需要设置。
        
        
        前端设置
        1.）原生ajax
            var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容
            
            // 前端设置是否带cookie
            xhr.withCredentials = true;
        
        2.）jQuery ajax
            $.ajax({
                ...
               xhrFields: {
                   withCredentials: true    // 前端设置是否带cookie
               },
               crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie
                ...
            })
            
        3.）vue框架
            a.) axios设置：
            
            axios.defaults.withCredentials = true
            b.) vue-resource设置：
            
            Vue.http.options.credentials = true
            
        
        服务端设置
            "Access-Control-Allow-Origin"：*
            
    7、 nginx代理跨域，webpack框架代理跨域
    
    8、 WebSocket协议跨域
        WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器
        全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
        原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装
        了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的
        浏览器提供了向下兼容。
    
    
#### 8.前端常见安全性问题有哪些？如何解决？
    
    1.跨站脚本攻击（XSS攻击）
        通过输入文本当中或者这HTML标签当中插入js脚本进行攻击，
        比如会在你的input标签或者img标签之前插入一些脚本文件
        就能攻击到你的网站。
        
        1.1 反射型xss，通过外部输入直接在浏览器触发，
            一般通过修改url参数形式加入攻击代码，诱导用户点击
            链接
        1.2 存储型xss，先把代码存储在数据库，web读取时触发
        
        解决办法：
            1.输入性的数据要存储前要进行过滤，对引号尖括号斜杠
            进行转义
            2.开启CSP，本质上是使用白名单，告诉浏览器只能加载
            特定资源。
            
         通过两种方式开启：
            设置http header：Content-Security-Policy:default-src 'self' //只允许加载本站资源
            设置meta标签<meta http-equiv="Content-Security-Policy">
            
    2.跨站请求伪造(CSRF攻击)
        
        CSRF攻击的原理:CSRF攻击过程的受害者用户登录网站A后，本地
        生成个人信息cookie。在A网站点击由攻击者构建一条恶意链接
        或者嵌套的页面跳转到B网站,携带着的用户cookie信息去访问B网站.让A网站造
        成是用户自己访问的假相,从而来进行一些列的操作,常见的就是转账.
        CSRF主要用于越权操作，因此多发生在有权限控制的地方。
        
        解决方案:
            (1) 验证码。
            (2) 增加token验证.因为cookie发送请求的时候会自动增加上，token不写在cookie所以不会，这样就避免了攻击
            (3) Referer验证。页面来源的判断
            
    3.SQL注入攻击 
        
        原理：
            SQL注入(SQL Injection)，应用程序在向后台数据库传递SQL(Structured Query Language，结构化查询语言)时，攻击者将SQL命令插入到Web表单提交或输入域名
            或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
            
            比如登录密码验证， 输入：userName = ``"1' OR '1'='1"``;
            
            后台拿着这个恶意输入的密码去检验时，解析为
            
            strSQL = ``"SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
            
            这样不需要密码也能登录
        
        解决方案：
            1、增加黑名单或者白名单验证 
                白名单验证一般指，检查用户输入是否是符合预期的类型、长度、数
                值范围或者其他格式标准。黑名单验证是指，若在用户输入中，包含
                明显的恶意内容则拒绝该条用户请求。在使用白名单验证时，一般会
                配合黑名单验证。
            2、数据转义
                把引号进行转义。
            3、防止系统敏感信息泄露
                对数据表的访问权限进行严格控制，尽量限制用户不必要的访问权限
    
    
    4.文件上传漏洞
        原理：
            没有限制文件后缀和类型，通过上传任意后台文件，并能够将这些文件传递给解释器，
            就可以在远程服务器上执行任意后台脚本
        
        解决方案：
            1、检查服务器是否判断了上传文件类型及后缀。
            2、定义上传文件类型白名单，即只允许白名单里面类型的文件上传。
            3、文件上传目录禁止执行脚本解析，避免攻击者进行二次攻击。
            
    5.http协议传输过程中容易受到劫持，使用https协议
    
    6.点击胁持
        点击胁持是一种视觉欺骗的攻击手段
        将iframe嵌套到自己的网页，将其透明化，诱导用户点击
        某个按钮，实际点击到透明化页面相应的按钮
        
        防御手段：
            1.x-frame-options
                http响应头中设置，有三个属性值：
                    DENY，表示页面不允许通过iframe展示
                    SAMEORIGIN 表示页面在同域名下的iframe才可以
                    ALLOW-FROM 表示页面可以指定来源iframe中展示
            
            2.js防御
                if(self == top){
                    self表示当前页面，top表示顶层页面，
                    相等表示，并没有被嵌套
                }else{
                    相反表示被嵌套，可以把页面html内容display：none
                    来清除掉
                }
      
#### 9.前端性能优化方法有哪些？
    
    1.网络资源
    
        1.1 静态资源的合并和压缩，
            请求资源压缩,使用gzip
                通过HTTP请求中的Accept-Encoding头来表示对压缩的支持
                Accept-Encoding: gzip,deflate
                
        1.2 静态资源缓存（浏览器缓存策略）。
            为 HTML 内容设置 Cache-Control 或 Expires 可以将 HTML 内容缓存起来，避免频繁向服务器端发送请求
            <meta http-equiv="Cache-Control" content="max-age=7200">
            <meta http-equiv="Expires" content="Mon,20Jul201623:00:00GMT">
            
            合理设置 Etag 和 Last-Modified 使用浏览器缓存，对于未修改的文件，
            静态资源服务器会向浏览器端返回304，让浏览器从缓存中读取文件，减
            少 Web 资源下载的带宽消耗并降低服务器负载。
            <meta http-equiv="last-modified" content="Sun,05 Nov 2017 13:45:57 GMT">
        
        1.3 使用CDN让静态资源加载更快。
        
        1.4 DNS预解析
            DNS预获取 dns-prefetch 提升页面载入速度,
            
            当浏览网页时，浏览器会在加载网页时对网页中的域名进行解析缓存，
            这样在单击当前网页中的连接时就无需进行DNS的解析，减少用户等
            待时间，提高用户体验。
            
            <meta http-equiv="x-dns-prefetch-control" content="on">
            <link rel="dns-prefetch" href="//www.zhix.net">
            
            DNS Prefetch 应该尽量的放在网页的前面，推荐放在 <meta charset="UTF-8"> 后面
            
        1.5 移动端首屏优化，保证首屏加载数据小于14kb    
        
        1.6 减少 Cookie 的大小
        
        1.7 避免重定向
        
        1.8 减少http请求，多图片可以合成雪碧图，小图片可以使用base64 内嵌图片，图标使用iconfont
        
        1.9 图片压缩处理
        
        1.10 图片懒加载
        
        1.11 图片预加载
            var images = new Array()  
            function preload() {  
                for (i = 0; i < preload.arguments.length; i++) {  
                    images[i] = new Image()  
                    images[i].src = preload.arguments[i]  
                }  
            }  
            preload(  
                "http://domain.tld/gallery/image-001.jpg",  
                "http://domain.tld/gallery/image-002.jpg",  
                "http://domain.tld/gallery/image-003.jpg"  
            )  
        
        1.12 srcset属性（响应式图片）和picture元素
        
            img 元素的 srcset 属性用于浏览器根据宽、高和像素密度来加载相应的图片资源。
            属性格式：图片地址 宽度描述w 像素密度描述x，多个资源之间用逗号分隔。例如
            <img src="small.jpg " srcset="big.jpg 1440w, middle.jpg 800w, small.jpg 1x" />
            上面的例子表示浏览器宽度达到 800px 则加载 middle.jpg ，达到 1400px 则加载 big.jpg。
            注意：像素密度描述只对固定宽度图片有效。
        
        1.13 避免使用 @import
            会破坏link的并行下载，导致css资源同步下载
        
        1.14 JS资源Preload预加载
        
                浏览器会在遇到如下link标签时，立刻开始下载main.js(不阻塞parser)，并放在内存中，
                但不会执行其中的JS语句。只有当遇到script标签加载的也是main.js的时候，浏览器才
                会直接将预先加载的JS执行掉。
                
                <link rel="preload" href="/main.js" as="script">
                
        1.15 使用http2.0
            http/1.1 存在的问题：
                1、tcp连接数有限
                    同域名下，最多6到8个（视浏览器情况而定）
                2.线头阻塞问题
                    每个tcp链接只能处理一个请求，请求多的情况下会形成阻塞
                3.header内容不能压缩
                    请求头内容不会变化太多，没有相应压缩方案
            
            http2的优势
                1.二进制分帧层
                    帧是数据传输最小单位，以二进制传输代替原本的明文传输，
                    原本的报文消息被划分为更小的数据帧
                2.多路复用
                    可在同一tcp连接不断发送帧，将多个请求分解成多个帧
                    每个请求为一个流，服务器接收帧数据拼接在各自的流中，
                    解决了线头阻塞问题和请求数量限制问题
                3.header可以压缩
                4.服务端可自动推送资源到浏览器
                5.请求可做优先级处理
                6.流量控制
                
    渲染性能方面
    
    1.浏览器的渲染：过程与原理
    
        关键渲染路径
            浏览器接收到服务器返回的HTML、CSS和JavaScript字节数据
            并对其进行解析和转变成像素的渲染过程被称为关键渲染路径。
            通过优化关键渲染路径即可以缩短浏览器渲染页面的时间。
            
        从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：
            
            1) DNS 解析
            2) TCP 连接
            3) HTTP 请求即响应
            4) 服务器响应
            5) 客户端渲染
        
        需要明白，这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以
        上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际
        页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM
        
        像素管道
            像素管道其实就是浏览器将渲染树绘制成像素的流程。管道的
            每个区域都有可能产生卡顿，即管道中的某一区域如果发生变化，
            浏览器将会进行自动重排，然后重新绘制受影响的区域。
            
            javascript-style-layout-paint-composite
            
            JavaScript：该区域其实指的是实现动画效果的方法，一般使用JavaScript来实现动画
            Style：该区域为样式计算阶段，根据选择器计算出节点应用的CSS规则，计算出每个节点的样式并应用。
            Layout：该区域为布局计算阶段，根据样式来计算元素的大小以及位置。
            Paint：该区域为绘制阶段，浏览器会先创建绘图调用的列表，然后填充像素。
            Composite：该区域为合成阶段，浏览器将多个图层按照正确顺序绘制到屏幕上。
        
        
        Dom树的构建程
            
            整个DOM树的构建过程其实就是： 字节 -> 字符 -> 令牌 -> 节点对象 -> 对象模型，
            
            先将HTML的原始字节数据转换为文件指定编码的字符，即标签，然后浏览器会根据HTML
            规范来将字符串转换成各种令牌，令牌具有各种意义和规则， 接下来每个令牌都会被转
            换成定义其属性和规则的对象（这个对象就是节点对象）,DOM树构建完成，整个对象集
            合就像是一棵树形结构。
            
        浏览器关键渲染路径的整个过程：
            1) 处理HTML标记数据并生成DOM树。
            
            2) 处理CSS标记数据并生成CSSOM树。
            
            3) 将DOM树与CSSOM树合并在一起生成渲染树。
            
            4) 遍历渲染树开始布局，计算每个节点的大小位置信息。
            
            5) 将每个节点绘制到屏幕。    
            
        
        
        阻塞渲染：CSS 与 JavaScript
            谈论资源的阻塞时，我们要清楚，现代浏览器总是并行加载资源。例如，当 HTML 解析器（HTML Parser）
            被脚本阻塞时，解析器虽然会停止构建 DOM，但仍会识别该脚本后面的资源，并进行预加载。
            
            同时，由于下面两点：
            
            默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。
            
            当浏览器遇到一个 script 标记时，DOM 构建将暂停，直至脚本完成执行。
            CSSOM 构建时，JavaScript 执行将暂停，直至 CSSOM 就绪。
            
            所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：
            
            1.CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。
            2.JavaScript 应尽量少影响 DOM 的构建。
            3.行内样式不便宜维护，写在一个外部样式表可以缓存，避免重复下载,重复样式会增加维护难度和增加文件大小
        
            
        css阻塞原因
            浏览器获得外部CSS文件的数据后，就会像构建DOM树一样开始构建CSSOM树，这个过程没有什么特别的差别。
        
            link 标签（无论是否 inline）会被视为阻塞渲染的资源，会优先处理，直至cssom构建完毕。
            注：用内联CSS可以省略请求的步骤提高速度，但没有必要为了这点速度而丢失了模块化与可维护性
            
            渲染树（Render-Tree）的关键渲染路径中，要求同时具有 DOM 和 CSSOM，之后才会构建渲染树。
            即，HTML 和 CSS 都是阻塞渲染的资源。HTML 显然是必需的，因为包括我们希望显示的文本在内
            的内容，都在 DOM 中存放，那么可以从 CSS 上想办法。
            
            所以需要精简 CSS 并尽快提供它
            
            使用媒体查询可以让CSS资源可以在特定情况下才加载
            
            <!-- 根据网页加载时设备的方向，portrait.css 可能阻塞渲染，也可能不阻塞渲染。-->
            <link href="portrait.css" rel="stylesheet" media="orientation:portrait">
            <!-- 只在打印网页时应用，因此网页首次在浏览器中加载时，它不会阻塞渲染。 -->
            <link href="print.css"    rel="stylesheet" media="print">
            
            注意：1.css不会阻塞dom解析，但是会阻塞dom渲染，也是阻塞脚本执行
            
                    css文件放在「头部加载」，可以保证解析DOM的同时，解析css文件。因为，
                    CSS（外链或内联）会阻塞整个DOM的渲染，然而DOM解析会正常进行，所以
                    将css文件放在头部进行解析，可以加快网页的构建速度。
        
        JavaScript阻塞原因
            script标签会阻塞Dom树的构建，所以一般script内容都放在html尾部
            
            改变阻塞模式：defer 与 async
                注意 async 与 defer 属性对于 inline-script 都是无效的,
                都是针对设置了 src 属性的 script 标签。
                
                
                defer
                    <script src="app1.js" defer></script>
                    
                    defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未
                    停止解析，这两个过程是并行的。整个 document 解析完毕且 defer-script 也加载完
                    成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript
                    代码，然后触发 DOMContentLoaded 事件。
                    defer 不会改变 script 中代码的执行顺序，示例代码会按照 1、2、3 的顺序执行。
                    所以，defer 与相比普通 script，有两点区别：载入 JavaScript 文件时不阻塞 HTML 
                    的解析，执行阶段被放到 HTML 标签解析完成之后。
                
                async
                    <script src="app.js" async></script>
                    async 属性表示异步执行引入的 JavaScript，与 defer 的区
                    别在于，如果已经加载好，就会开始执行——无论此刻是 HTML 
                    解析阶段还是 DOMContentLoaded 触发之后。需要注意的
                    是，这种方式加载的 JavaScript 依然会阻塞 load 
                    事件。换句话说，async-script 可能在 DOMContentLoaded 
                    触发之前或之后执行，但一定在 load 触发之前执行。
                    
        加载部分html
            服务端在接收到请求时先只响应回HTML的初始部分，后续的HTML内容在需要时再通过AJAX获得。
        
        降低选择器的复杂度
            通过降低选择器的复杂性可以提升样式计算的速度。
            
        使用RequestAnimationFrame函数实现动画
            使用setTimeeout和setInterval实现动画可能会造成卡顿，而且影响性能。
            为什么？
            1.setTimeOut执行时间并不确定，setTimeout任务会放入异步队列，异步队列需要
             等待主线程任务执行完，才会检查异步队列任务，所以实际执行时间会晚一些
             
            2.刷新频率受分辨率、屏幕尺寸、类型影响而不同，所以setTimeOut的执行时间和
              刷新时间有可能不同，比如刷新时间为16ms，settimeout时间为10ms，当settimeout
              执行后，屏幕还没刷新，不断的累计偏差，就会出现卡顿，丢帧现象
              
            RequestAnimationFrame的优势
                最大的优势是由系统来决定回调函数的执行时机，配合系统的屏幕刷新时间执行。
                在浏览器缩下来的时候，settimeout仍然会执行，浪费cpu性能，而RequestAnimationFrame
                只会在屏幕刷新时才执行，所以动画流畅
                
        还可以使用不会触发布局与绘制的属性来实现动画
        
            尽量减少使用JS动画，因为JS 直接操作 DOM 极容易引起页面的重排
            
            有两种属性修改后会跳过布局与绘制阶段，这显然会减少不少性能开销。
            目前只有两种属性符合这个条件：transform和opacity 。
            
            需要注意的是，使用transform和opacity时，更改这些属性所在的元素应
            处于其自身的图层，所以我们需要将设置动画的元素单独新建一个图层
            
            will-change属性可以创建图层
                该属性告知浏览器该元素会有哪些变化，这样浏览器可以在元素属性真正发
                生变化之前提前做好对应的优化准备工作。
                
                .moving-element {
                  will-change: transform;
                }
                
            但不要认为will-change可以提高性能就随便滥用，使用will-change进行预优化
            与创建图层都需要额外的内存和管理开销，随便滥用只会得不偿失
            
            
        避免大型、复杂的布局和布局抖动
            更改样式时，浏览器会检查任何更改是否需要计算布局，以及是否需要更新
            渲染树。对“几何属性”（如宽度、高度、左侧或顶部）的更改都需要布局计算。
            
            浏览器每次进行布局计算时几乎总是会作用到整个DOM，如果有大量元素，
            那么将会需要很长时间才能计算出所有元素的位置与尺寸。
            
            所以
                
                1.尽量避免在运行时动态地修改几何属性，即避免布局操作
                2.尽量使用flexbox，性能高
                3.避免强制同步布局。
                    首先 JavaScript 运行，然后计算样式，然后布局。但是，可以使用 JavaScript 强制浏览器提前执行布局。这被称为强制同步布局。
                    如果先更改一个元素的高度，再获取其高度，js就会强制布局，
                    因为更改了高度之后，需重新布局计算，然后再获取高度，这样
                    很浪费性能。
                4.避免布局抖动
                    避免接二连三地执行大量强制同步布局
            
        web worker优化
            部分JavaScript运行时间比较长，会阻塞其他渲染工作运行，可以使用web worker
            创建子线程运行该js文件，这样就不影响主线程渲染，然后通过postmessage通信
        
        尽量避免使用<table>、<iframe>
            <table> 内容的渲染是将 table 的 DOM 渲染树全部生成完并一次性绘制到页面上的，
            长表格渲染时很耗性能，应避免使用，可以使用 <ul> 
            代替。尽量使用异步的方式动态添加 iframe，因为 iframe 内资源的下载进程会阻塞
            父页面静态资源的下载与 CSS 及 HTML DOM 的解析。
            
        移动端使用 Viewport 固定屏幕渲染，可以加速页面渲染内容
            <!--设置viewport不缩放-->
            <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
            
            一般认为，在移动端设置 Viewport 可以加速页面的渲染，同时可以避免缩放导致页面重排重绘。在移动端固定 Viewport 设置的方法如下。
            
        使用 CSS3 动画，开启GPU加速
            -webkit-transform:translateZ(0);
            -ms-transform:translateZ(0);
             -o-transform:translateZ(0);
                transform:translateZ(0);
            
            让浏览器执行 3D transform。浏览器通过该样式创建了一个独立图层，图层中的动画则有GPU进行预处理并且触发了硬件加速。
            
            通过-webkit-transform:transition3d/translateZ开启GPU硬件加速之后，有些时候可能会导致浏览器频繁闪烁或抖动，可以尝试以下办法解决之：
                -webkit-backface-visibility:hidden;
                -webkit-perspective:1000;
        
        不滥用 float
                在 DOM 渲染树生成后的布局渲染阶段，使用 float 的元素布局计算比较耗性能，所以
                尽量减少 float 的使用，推荐使用固定布局或 flex-box 弹性布局的方式来实现页面元素布局。
        
        预渲染 
            可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染 
                <link rel="prerender" href="http://poetries.com">
            预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染
            适合变化少，需要seo的页面
            
            vue中配置预渲染
                使用prerender-spa-plugin，配置特定路由页面来匹配需要预渲染的页面
            
    脚本类
        
        1.尽量使用id选择器
            选择器选择页面 DOM 元素时尽量使用 id 选择器，因为 id 选择器速度最快
            
        2.合理缓存 DOM 对象
            重复使用的DOM对象，应该缓存起来，不要每次重新获取
            
        3.页面元素尽量使用事件代理，避免直接事件绑定    
            使用事件代理可以避免对每个元素都进行绑定，并且可以避免出现内存泄露及
            需要动态添加元素的事件绑定问题，所以尽量不要直接使用事件绑定。
            
        4.防止高频执行事件，即事件的防抖 
            比如一些resize事件可以高频率执行，如果回调冗长，
            会有可能卡死
            
            可以在回调函数中增加延时器，在一定时间内触发就刷新延时器
            
        5.减少作用域链查找
            如果在循环中需要访问非本作用域下的变量时请在遍历之前用
            局部变量缓存该变量，并在遍历结束后再重写那个变量，这一
            点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，
            访问时的查找次数是最多的
                低效率的写法：
                    // 全局变量 
                    var globalVar = 1; 
                    function myCallback(info){ 
                        for( var i = 100000; i--;){ 
                            //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 
                            globalVar += i; 
                        }
                    } 
                    
                更高效的写法：
                    // 全局变量 
                    var globalVar = 1; 
                    function myCallback(info){ 
                        //局部变量缓存全局变量 
                        var localVar = globalVar; 
                        for( var i = 100000; i--;){ 
                            //访问局部变量是最快的 
                            localVar += i; 
                        } 
                    }    
                    //本例中只需要访问 2次全局变量
                    
        6.移动端使用touchstart、touchend代替click
            移动端click有300ms的延迟，因为浏览器要判定是否为双击，所以用tap事件代替
  
  
  chrome的performance可以查看页面的性能指标，还有问题所在
        火焰图中main表，展开后点击右上角有红色三角形的事件块，表示有警告，
        根据提示可以优化
        https://www.cnblogs.com/ranyonsue/p/9342839.html
        https://segmentfault.com/a/1190000011516068?utm_source=tag-newest
  
  ![image](http://image.uisdc.com/wp-content/uploads/2015/01/20150108170945527.png)  
  
  
#### 10.双飞翼布局

    圣杯布局有缺陷，使用了相对定位，当小于一个最小宽度，布局会崩
    
    双飞翼布局特点
        1. 两侧宽度固定，中间宽度自适应
        2.中间部分在DOM结构上优先，以便先行渲染
        
    <body>
        <div id="header"></div>
        <div id="container" class="column">
            <div id="center">center</div>
        </div>
        <div id="left" class="column">left</div>
        <div id="right" class="column">right</div>
        <div id="footer"></div>
    <body>
    按道理，container在left、right浮动元素前面，浮动元素应在
    container下面，但是margin-left取负值，left取了-100%
    取父元素的宽度，回到第一行，就到了container左边，而
    right取的自己的负值，刚好换行到第一行右边
    
    #container {
        width: 100%;
    }
    
    .column {
        float: left;
    }
    
    #center {
        margin-left: 200px;
        margin-right: 150px;
        background-color: chocolate
    }
    
    #left {
        width: 200px; 
        margin-left: -100%;
        background-color: blue
    }
    
    #right {
        width: 150px; 
        margin-left: -150px;
        background-color: aqua
    }
    
    #footer {
        clear: both;
    }
    
    其他实现方法
        
        <div id="container">
            <div id="center" class="column"></div>
            <div id="left" class="column"></div>
            <div id="right" class="column"></div>
        </div>
        
    1.使用flex
        #container {
            display: flex;
        }
        
        #center {
            flex: 1;
        }
        
        #left {
            flex: 0 0 200px;
            order: -1;
        }
        
        #right {
            flex: 0 0 150px;
        }
        
        
#### 11.vue 中的slot插槽
    1.普通插槽 slot
        父组件: 负责分发插槽内容
                <child ref=child>
                    我是父组件分发给 child 的所有内容
                </child>
                父组件获取子组件可以通过 this.$refs.child 来做操作
        
        子组件:  <template>
                    <slot>这里可以放一些默认值</slot>
                </template>
                模板中放置一个 <slot></slot>组件,
                我们可以自定义组件中的方法和数据,封装一些通用逻辑,比如前几篇中封装的 scroll滚动组件
                
    2.具名插槽 子组件通过 name 属性 来匹配父组件分发的内容
        父组件: 添加 slot 属性来作为标识
                <div slot="header">我是 header 分发的内容 111</div>
                <div slot="main">我是 main 分发的内容222</div>
                <div slot="footer">我是 footer 分发的内容333</div>
        
              在2.6.0 以上使用的是 v-slot:header; 默认插槽为: v-slot:default
        
        子组件: slot 添加 name 属性来接受父组件分发的 DOM 元素
                <template>
                    <slot name="header"></slot>
                    <slot name="main"></slot>
                    <slot name="footer"></slot>
                </template>
            当然,我们还可以调换插槽的位置...            
            
    3.作用域插槽 父组件可以接收来自子组件的 slot 传递过来的参数值
        可以理解为: 子组件中的作用域插槽可以为父组件中的插槽的展示提供数据
        
        子组件:
            <template>
                <div>
                    <slot name="header" :value="value"></slot>
                </div>
            </template>
            <script>
                export default {
                    data() {
                        return {
                            value: '我是子组件的值'
                        }
                    }
                }
            </script>
        
        父组件:
            <child v-slot:header="{value}">{{value}}</child>
            
            可以使用解构 v-slot:header="{value}", 将子组件传过来的值解构
            
#### 12.js函数的执行过程
    
    1.确定this的值
    2.创建作用域
    3.处理形参/实参：
        对于传入的实参，从左往右依次执行：如果对应的形参
        在本作用域中还没有定义，则在本作用域中声明形参，并赋值。如果已经
        定义过了，则重新给其赋值。
        
    4. 处理函数定义（没有定义过才声明，无论如何都重新赋值）：
        对该函数中所有的定义的函数，按照代码写的顺序依次执行：如果这个变
        量名在本作用域中还没有定义，则在本作用域中声明这个函数名，并且赋
        值为对应的函数，如果定义了这个变量，在可写的情况下重新给这个变量
        赋值为这个函数，否则抛出异常。
        
    5.处理 "arguments"（没有定义过才声明和赋值）:
        如果在本作用域中没有定义 arguments，则在本作用域中声明arguments并给其赋值。    
    
    6. 处理变量声明（没有定义过才声明，不赋值）：
        变量声明依次执行：如果在本作用域中没有定义这个变量，则在本作用域中声明这个变量，赋值为undefined
        
    7. 然后执行函数代码。（当然是去变量定义里面的 var 执行）
    
    变量提升和函数提升
        一、什么是提升（Hosting）？
            引擎会在解释JavaScript代码之前首先对齐进行编译，
            编译过程中的一部分工作就是找到所有的声明，并用
            合适的作用域将他们关联起来，这也正是词法作用域
            的核心内容。
            
            简单说就是在js代码执行前引擎会先进行预编译，预
            编译期间会将变量声明与函数声明提升至其对应作用
            域的最顶端。
            
                console.log(a);
                var a = 3;
                //预编译后的代码结构可以看做如下
                var a; // 将变量a的声明提升至最顶端，赋值逻辑不提升。
                console.log(a); // undefined
                a = 3; // 代码执行到原位置即执行原赋值逻辑
            
            
            函数提升只会提升函数声明，而不会提升函数表达式。
            注意：函数提升优先级高于变量提升，不会被变量声明覆盖，但是赋值会覆盖
            
                console.log(foo1); // [Function: foo1]
                foo1(); // foo1
                console.log(foo2); // undefined
                foo2(); // TypeError: foo2 is not a function
                function foo1 () {
                	console.log("foo1");
                };
                var foo2 = function () {
                	console.log("foo2");
                }
            
            
                var a = 1;
                function foo() {
                    a = 10;
                    console.log(a);
                    return;
                    function a() {};
                }
                foo();
                console.log(a);
            
            上面的代码块经过预编译后可以看做如下形式（只分析foo方法内部情况）：
            
                var a = 1; // 定义一个全局变量 a
                function foo() {
                    // 首先提升函数声明function a () {}到函数作用域顶端， 然后function a () {}等同于 var a =  function() {};最终形式如下
                    var a = function () {}; // 定义局部变量 a 并赋值。
                    a = 10; // 修改局部变量 a 的值，并不会影响全局变量 a
                    console.log(a); // 打印局部变量 a 的值：10
                    return;
                }
                foo();
                console.log(a); // 打印全局变量 a 的值：1
                
            函数提升优先级高于变量提升

#### 13.new一个对象的过程中发生了什么嘛
    1. 创建空对象；
        var obj = {};
    2. 设置新对象的constructor属性为构造函数的名称，设置新对象的__proto__属性指向构造函数的prototype对象；
        obj.__proto__ = ClassA.prototype;
    3. 使用新对象调用函数，函数中的this被指向新实例对象：
        ClassA.call(obj);//{}.构造函数();
    4. 将初始化完毕的新对象地址，保存到等号左边的变量中
    
#### 14.宏任务跟微任务
    macro-task(宏任务)：包括整体代码script，setTimeout，setInterval
    
    micro-task(微任务)：Promise，process.nextTick    
    
#### 15.防抖和节流
    综合应用场景
    
    防抖(debounce):就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
    
    节流(throttle):就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
    
    防抖函数分为非立即执行版和立即执行版。
        非立即执行版：触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
        立即执行版：触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。
    
    所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。
    
        对于节流，一般有两种方式可以实现，分别是时间戳版和定时器版。
        时间戳版的函数触发是在时间段内开始的时候
        延时器版的函数触发是在时间段内结束的时候。
        
#### 16. 数组的常用方法        
        改变原数组的方法
            splice() 添加/删除数组元素
                参数:
                   1.index：必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。
                   2.howmany：可选。要删除的项目数量。如果设置为 0，则不会删除项目。
                   3.item1, ..., itemX：可选。向数组添加的新项目。
                插入操作：splice(index 0 item)
                替换操作: splice(index 1 item)
                删除操作: splice(index 1)
                
            sort() 数组排序
                arrayObject.sort(fn)
            
            pop() 删除一个数组中的最后的一个元素
            shift() 删除数组的第一个元素
            push() 向数组的末尾添加元素
            unshift() 向数组的开头添加一个或更多元素
            reverse() 颠倒数组中元素的顺序
            copyWithin() 指定位置的成员复制到其他位置
                array.copyWithin(target, start = 0, end = this.length)
            fill() 填充数组
                参数:
                   1.value	必需。填充的值。
                   2.start	可选。开始填充位置。
                   3.end	可选。停止填充位置 (默认为 array.length)
                   
        不改变原数组的方法
            slice() 浅拷贝数组的元素
            join() 数组转字符串
            concat() 合并两个或多个数组
            indexOf() 查找数组是否存在某个元素,返回值: 返回下标
            lastIndexOf() 查找指定元素在数组中的最后一个位置
            includes() 查找数组是否包含某个元素,返回值: 返回布尔
            
#### 17.js原型和原型链

        每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性
        
        访问一个对象的属性时，如果这个对象内部不存在这个属性，那么
        就会去prototype里找这个属性，这个prototype又会有自己的prototype,
        一直找下去，也就是所说的原型链的概念。
        
#### 18. Promise        
                
        /*Promise 的简单实现*/
        
        class myPromise {
            constructor(fn) {
                const isFunction = variable => typeof variable === 'function'
                if (!isFunction(fn)) {
                    throw new Error('MyPromise must accept a function as a parameter')
                }
                this._status = 'PENDING';
                this._value = '';
                this._resolveQueues = [];
                this._rejectedQueues = [];
                try {
                    fn(this.resolve.bind(this), this.reject.bind(this))
                } catch (err) {
                    this.reject(err)
                }
            }
            resolve(val) {
                if (this._status === 'PENDING') {
                    this._status = 'RESOLVE';
                    this._value = val;
                    this._resolveQueues.forEach(cb=>cb())
                }
            }
            reject(val) {
                if (this._status === 'PENDING') {
                    this._status = 'REJECT';
                    this._value = val;
                    this._rejectedQueues.forEach(cb=>cb())
                }
            }
            then(Resolve, Reject) {
                const { _status, _value } = this;
        
                switch (_status) {
                    case 'PENDING':
                        this._resolveQueues.push(Resolve);
                        this._rejectedQueues.push(Reject);     
                    break;
                    case 'RESOLVE':
                        Resolve(_value)
                    break; 
                    case 'REJECT':
                        Reject(_value)
                    break;
                }
            }
        }  
            

#### 19.浅拷贝和深拷贝的区别
    数据类型：
        基本类型：number，string，boolean，null，undefined，symbol
        引用类型：object，array，function
    
    基本类型储存的时候
        名值存储在栈内存中
        
        所以直接通过“=”赋值时就能复制
        
    引用类型储存的时候
        名存在栈内存中，值存在于堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值
        
        var a = {a:1}; var b = a;a.a = 2; b.a//2
        通过“=”赋值，就是只复制了名和引用地址，所以修改一个值会影响其他值
    
    
    浅拷贝只是拷贝了栈内存的名和引用地址
    深拷贝是创建了新内存存放名和值
        
    深拷贝方法：
        JSON.parse(JSON.stringify(obj))
        
    浅拷贝：
        slice，es6的Object.assign，concat，ES6 的对象扩展let newObj = {...obj}，
        以上方法仅仅拷贝了第一层，内部更深的属性却仍然使用公用地址
        比如 arr = [{a:1,b:2},1] 修改里面的对象，依然会使复制对象改变
        
#### 20.阻止冒泡和默认行为
    防止冒泡和捕获
        w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = true
        
        window.event? window.event.cancelBubble = true : e.stopPropagation();
        
        冒泡: 一个按钮是绑定一个”click”事件，那么”click”事件会依次在它的父级元素中被触发
        
        捕获从上到下，冒泡从下到上
        
        在冒泡事件和捕获事件同时存在的情况下，捕获事件优先级高一点
        
        
    取消默认事件
        w3c的方法是e.preventDefault()，IE则是使用e.returnValue = false;    
        
#### 21. set 集合
        允许你存储任何类型的唯一值，无论是原始值或者是对象引用
        Set集合内部是通过Object.is() 方法进行判断
        
        对象只要地址不一样，就算里面可枚举属性值一样，Object.is(a,b)都会返回false
        
        
        set方法：
            add(value)：添加某个值，返回 Set 结构本身。
            delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。
            has(value)：返回一个布尔值，表示该值是否为Set的成员。
            clear()：清除所有成员，没有返回值。
            
            let a = new Set();
                a.add(1).add(2); // a => Set(2) {1, 2}
                a.has(2);        // true
                a.has(3);        // false
                a.delete(2);     // true  a => Set(1) {1}
                a.clear();       // a => Set(0) {}
        
        数组去重
            let a = new Set([1,2,3,3,4]);
            [...a]; // [1,2,3,4]
            a.size; // 4
            
            // 数组去重
            [...new Set([1,2,3,4,4,4])];// [1,2,3,4]
            
#### 22.实现一个new操作符
        
        通用规则
            对象有__proto__属性，函数有prototype属性；
            对象由函数生成;
            生成对象时，对象的__proto__属性指向函数的prototype属性。
    
        function new(func){
            var res = {};
            if (func.prototype !== null) {
                res.__proto__ = func.prototype;
            }
            
            var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));
            if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
                return ret;
            }
            
            return res
            
        }

#### 22.1 call、apply和bind的区别
        普通函数调用时
            function fn(){
                
            }
            fn()
            
        实际上是
            fn.call(undefined), 而如果this是null或undefined 默认为window
            
        而对象调用内部函数时，实际上
            obj.fn() => obj.fn.call(obj)
            
        call和apply是传入this值然后调用，
        bind只是绑定this值
        
        fn.call(obj, parms) 第一个为传入this值，为null则默认为window，后面参数为函数参数
        fn.apply(obj,arr) 第一个参数同理，但是第二个参数为数组，数组里为函数参数
        
    
#### 23.闭包的形式写防抖和节流函数
        防抖
        function debounce(fn, wait = 50, immediate){
            let timer;
            
            return function(){
                if(immediate){
                    fn.apply(this,arguments)
                    return
                }
                if(timer)cleanTimeout(timer)
                
                timer = setTimeout(()=>{
                    fn.apply(this,arguments)
                },wait)
            }
        }
        
        节流
        function throttle(fn, wait){
            let pre = new Date()
            return function(){
                const arg = arguments;
                const now = new Date();
                if(now - pre > wait){
                    pre = new Date();
                    fn.apply(this,arg)
                }
            }
        }
        
        注：获取两个时间差，直接new Date() - 另一个new Date(), 可以获取时间差毫秒数
        
#### 24.Vue的双向数据绑定原理是什么？        
        vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通
        过Object.defineProperty()来劫持各个属性的setter，getter，
        在数据变动时发布消息给订阅者，触发相应的监听回调。
        
        Object.defineProperty(model, "message", {
            set: function(newValue) {
                this.value = newValue;
            },
            get: function() {
                return this.value;
            }
        })
        
        
        vue3.0使用Proxy来绑定数据
            Object.defineProperty的缺点：
                1. 在Vue中，Object.defineProperty无法监控到数组下标的变化，
                2. 如果被监听对象在执行监听之后又重新添加了属性,这些属性值则无法监听到
                
            proxy
                Proxy是 ES6 中新增的一个特性
                
                基本用法：
                let p = new Proxy(target, handler);
                参数：
                target: 是用Proxy包装的被代理对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。
                handler: 是一个对象，其声明了代理target 的一些操作，其属性是当执行一个操作时定义代理的行为的函数
        
#### 25.对生命周期的理解
        总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后
        
        beforeCreate 创建前执行（还未初始化挂载元素$el和数据对象data）
        
        created 完成创建 （初始化了data数据） 
        
        beforeMount 载入前（初始化挂载元素el，vue实例还没挂载，data数据还没渲染。）（message指的是data的属性值）
        
        mounted 载入后html已经渲染(vue实例挂载完成，data数据成功渲染。)
        
        beforeUpdate 更新前状态（view层的数据变化前，不是data中的数据改变前，data中数据改变导致view层数据的改变）
        
        updated 更新状态后（数据更新后）
        
        beforeDestroy 销毁前
        
        destroyed 销毁后 （在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在）
        
        说一下每一个阶段可以做的事情
        
        beforeCreate:可以在这里加一个loading事件，在加载实例时触发。
        
        created:初始化完成时的事件写这里，如果这里结束了loading事件，异步请求也在这里调用。
        
        mounted:挂在元素，获取到DOM节点
        
        updated:对数据进行处理的函数写这里。
        
        beforeDestroy:可以写一个确认停止事件的确认框。
        
#### 26. vue-router 有哪几种导航钩子?
        三种
        
        全局导航钩子（跳转前进行判断拦截）
        
            router.beforeEach(to, from, next),  跳转前
            router.beforeResolve(to, from, next), 和 router.beforeEach 类似，区别是在导航被确认之前，
                                                  同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用
            router.afterEach(to, from) 跳转后，守卫不同的是，这些钩子不会接受 next 函数也不会改变导航本身
        
        组件内钩子
        
            beforeRouteEnter 渲染该组件前，不能调用this，只有next里的回调函数有vm实例对象
            beforeRouteUpdate   复用组件时触发，比如/foo/1 进入 /foo/2，一样的组件实例会复用，就会触发这个钩子
            beforeRouteLeave 导航离开该组件的对应路由时调用
            
            export default {
                  data() {
                    return {
                
                    }
                  },
                  beforeRouteEnter(to, from, next) {
                    next(vm => {
                      //因为当钩子执行前，组件实例还没被创建
                      // vm 就是当前组件的实例相当于上面的 this，所以在 next 方法里你就可以把 vm 当 this 来用了。
                      console.log(vm);//当前组件的实例
                    })
                  },
                  beforeRouteUpdate(to, from, next) {
                      
                  },
                  beforeRouteLeave(to, from, next) {
                      
                  }
            }
        
        路由配置文件，单独路由独享组件
            beforeEnter
            
                 routes: [
                    {
                      path: '/foo',
                      component: Foo,
                      beforeEnter: (to, from, next) => {
                        // ...
                      }
                    }
                  ]
            
        完整的导航解析流程
            1.导航被触发。
            2.在失活的组件里调用离开守卫beforeRouterLeave。
            3.调用全局的 beforeEach 守卫。
            4.在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
            5.在路由配置里调用 beforeEnter。
            6.解析异步路由组件。
            7.在被激活的组件里调用 beforeRouteEnter。
            8.调用全局的 beforeResolve 守卫 (2.5+)。
            9.导航被确认。
            10.调用全局的 afterEach 钩子。
            11.触发 DOM 更新。
            12.用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。
            
#### 27. 组件之间的通信
        1.prop/$emit
            <boxTable
                  :boxType="boxType"
                ></boxTable>
                
                子组件接收 props:['boxType']
                
                <boxTable
                  :boxType="formData.boxType"
                  @changeList="changeList"
                ></boxTable>
                
                子组件触发 this.$emit("changeList", this.boxList); 后面的为参数
        
        2.ref、$parent/$children
            获取父/子组件的实例
            
        3.建立事件中心
            新建一个vue实例
                bus.js
                    import Vue from'vue'
                    export defalut new Vue()
                    
                其他组件
                    import Bus from './bus'
                    ...
                    
                    add(){
                        Bus.$emit('test','csss')
                    }
                    
                其他组件
                    
                    mounted(){
                        Bus.$on('test',function(msg){
                            
                        })
                    }
        4.$attrs / $listeners
            $attrs表示父组件在子组件上通过v-bind绑定的所有属性的集合
            不包括props，class，style
            子组件通过$attrs.xxx获取绑定的值
            
            可以通过v-bind="$attrs"传入下一个组件
            
            $listeners是事件的集合，同理
            
        5.provide / inject
            祖先组件设置provide，后面无论多深的子组件都可以通过inject注入provide的值
            
              import childOne from '../components/test/ChildOne'
              export default {
                name: "Parent",
                provide: {
                  for: "demo"
                }
              }
              
              export default {
                inject: ['for'],
                data() {
                  return {
                    demo: this.for
                  }
                }
              }
        
        6.vuex通信        
                    
#### 28.服务端渲染和客户端渲染的利弊
        服务端                    客户端
    
    利  首屏渲染快             前后端分离
        利于seo                局部刷新，无需更新整个页面，体验更好
        可以生成缓存片段，     节省服务器性能，部署简单
        生成静态文件           交互性好，可以实现各种效果    
        节能，尤其移动端更省电
    
    弊  不利于前后端分离，          SEO差
        开发效率低，
        不容易维护，前端改，  首屏渲染慢，渲染前需要下载一堆资源
        后端也要改，
        占用服务器资源
        
#### 29.cookie、session、sessionStorage和localStorage的理解以及它们之间的区别
    Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在
    
    Web Storage是为了在本地“存储”数据而生。html5中
    的 Web Storage 包括了两种存储方式：sessionStorage和localStorage
    
    
    cookie：容量小，4kb左右；
            每次请求会携带在HTTP头中；
            只能保存字符串类型，以文本的方式
            保存在浏览器，可以由服务器设置；
            可设置有效时间，默认关闭页面就失效；
            
            cookie参数：
                        1.Domain：域，表示当前cookie所属于哪个域或子域下面。
                        2.Path：表示cookie的所属路径。
                        3.Expire time/Max-age：表示了cookie的有效期。
                        4.secure：表示该cookie只能用https传输。
                        5.httponly：表示此cookie必须用于http或https传输。
                        
            缺陷：
                    1.cookie会被附加在每个HTTP请求中，所以无形中增加了流量。
                    2.由于在HTTP请求中的cookie是明文传递的，所以安全性成问题。（除非用HTTPS)
                    3.Cookie的容量小，只有4kb左右，每个域名下的cookie数量有限
                    4.用户可以操作cookie安全性低
                    
            应用场景：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。
                           如果我们删除cookie，则每次登录必须从新填写登录的相关信息。
                　　　（2）保存上次登录的时间等信息。
                      （3）保存上次查看的页面
                      （4）浏览计数        
    
    session：保存在服务器端；
             session大小没有限制；
             session的安全性大于cookie；
             常见用于单点登录；
             服务器收到请求时，会先检查客户端请求中是否有sessionid。
             
             有则根据id返回对应session对象，没有则在服务器创建session对象，
             并返回sessionid给客户端。通常使用cookie方式存储sessionid到客户端。
             如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 实现，
             重写URL将SessionID拼接到访问地址后。
            
            应用场景：
                （1）网上商城中的购物车
            　　（2）保存用户登录信息
            　　（3）将某些数据放入session中，供同一用户的不同页面使用
            　　（4）防止用户非法登录
            　　
            缺陷：
                1.由于session保存在服务器，对于用户在线人数较多的网站，服务器的内存压力会比较大。    
                2.依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全
            　　
    为什么session比cookie安全？
    
        cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。
        
        Cookie欺骗：比如修改cookie的信息内容，获取了不同的用户权限
        
    　　原因如下：（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；
        　　　　　　　（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；
        　　　　　　　（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。
        　　　　　　　（4）sessionID是加密的
        　　　　　　　（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。
            
    localStorage: 不主动清除就会永久保存；
                  容量5mb；
                  仅保存在客户端，不参与通信；
                  常用于购物车信息的保存；
                  只能存储字符串类型
                  
                  localStorage和sessionStorage都具有相同的操作方法，如setItem,
                  getItem,removeItem,clear等方法，不像cookie需要前端开发者自己
                  封装setCookie，getCookie
                  
    sessionStorage: 一般用于会话，关闭页面或浏览器后被清除；
                    容量5mb；
                    仅保存在客户端，不参与通信；
                    只能存储字符串类型
                    
                    sessionStorage引入了一个“浏览器窗口”的概念，sessionStorage是
                    在同源的窗口中始终存在的数据。只要这个浏览器窗口没有关闭，即
                    使刷新页面或者进入同源另一个页面，数据依然存在。但是sessionStorage
                    在关闭了浏览器窗口后就会被销毁。同时独立的打开同一个窗口同一
                    个页面，sessionStorage也是不一样的。
                    
#### 30.什么是闭包，如何使用它，为什么要使用它？ 
    1.什么是闭包
        闭包就是指有权访问另一个函数作用域中的变量的函数。
        闭包可以使函数的变量一直保存在内存当中。
    
        闭包需要满足三个条件：【1】访问所在作用域；【2】函数嵌套；【3】在所在作用域外被调用
    
    2.如何使用闭包
        闭包有两个最大的用处，一个是可以在全局作用域中读取内部函数的的变量，
        另一个就是可以让闭包作用域里的变量始终保存在内存中而不会被垃圾回收处理掉。
        
        利用函数嵌套的方式，将引用局部变量的匿名函数通过return，暴露出去
    
    3.为什么使用闭包？
        应用闭包的主要场合是：设计私有的方法和变量。
        
        闭包可以隐藏变量，使其局部变量可以被外部引用，这样可以避免这个局部变量被污染的同时还可以
        被使用
        
    4.如何释放闭包内存
        由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。
        因此可以手动解除对匿名函数的引用，以便释放内存。
        
        function f2(){
            var n=22;
            var nAdd=function(){n++};
            return function(){
                return {
                    n:n,
                    nAdd:nAdd
                }
            }
        }
        //result2就是创建了一个匿名函数
        var result2=f2();
        
        //解除对匿名函数的引用，以便释放内存
        result2=null;
        
    5.闭包实例：
        for 循环中打印
            for (var i = 0; i < 4; i++) {
              setTimeout(function() {
                console.log(i);
              }, 300);
            }
        打印出来都是4，如何用闭包解决
        
        for (var i = 0; i < 4; i++) {
          setTimeout(
            (function(i) {
              return function() {
                console.log(i);
              };
            })(i),
            300
          );
        }
        
        
        
        获取元素添加点击事件
        var op = document.querySelectorAll("p");
        for (var j = 0; j < op.length; j++) {
          op[j].onclick = function() {
            alert(j);
          };
        }
        //alert出来的值是一样的
        
        // 解决办法一:
        for (var j = 0; j < op.length; j++) {
          (function(j) {
            op[j].onclick = function() {
              alert(j);
            };
          })(j);
        }
        // 解决办法二:
        for (var j = 0; j < op.length; j++) {
          op[j].onclick = (function(j) {
            return function() {
              alert(j);
            };
          })(j);
        }
        //解决方法三其实和二类似
        for (var j = 0; j < op.length; j++) {
          op[j].onclick = (function() {
            var temp = j;
            return function() {
              alert(temp);
            };
          })();
        }
    
    6.闭包的作用域链
        其作用域链是从inner的函数作用域到outer作用域
        
#### 31.事件委托是什么？它的实现原理及优点是什么？
    1.事件委托
        事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。
        
    2.事件委托原理
        事件委托是利用冒泡阶段的运行机制来实现的，所以才可以在父元素来监听子元素触发的事件。
        
    3.事件委托优点
        3.1、减少了事件监听器，只需要在祖先元素定义一次即可。
        3.2、减少内存消耗，提高了页面性能，这主要还是减少了事件处理函数的数量
        3.3、动态绑定事件，动态新增的子元素无需重新绑定事件。
        
    4.缺点
        4.1 事件委托基于冒泡，对于不冒泡的事件不支持。
        4.2 层级过多，冒泡过程中，可能会被某层阻止掉。
        4.3 委托层级过高，会导致频繁调用处理函数，或者触发事件误判，
            建议就近委托
        
    4.事件委托 的局限
        focus、blur 之类的事件本身没有事件冒泡机制，所以无法委托；
        mousemove、mouseout 这样的事件，虽然有事件冒泡，但是每次都要计算它的位置，
        对性能消耗高，而且很麻烦，因此也是不适合用事件委托。
        
    
    事件执行
        参照w3c规范，采用了先捕获，再冒泡的执行方式。
        
        addEventListener第三个参数默认为false，即冒泡方式，true为捕获方式
        
        var a = document.querySelector('#a')
        a.addEventListener('click',function(e){
            alert(e.target+'外部元素在冒泡阶段')
        },false)
        
        为同一元素绑定的两个事件，按照顺序执行；
        根据执行事件方式不同，先执行捕获方式的，无论代码顺序如何；
        如果没有子元素，则不存在冒泡或者捕获，按照代码顺序执行
        
        stoppropagation()所做的事情可以这么理解，阻止父级元素冒泡阶段的事件
        ie 阻止冒泡 event.cancelBubble=true
        
    由于dom2事件 ie不兼容，IE有自己的事件处理程序方法：attachEvent()和detachEvent()。
    这两个方法的用法与addEventListener()是一样的    
        
#### 32. dom 0级事件 和 dom 2级事件        
    
    0级DOM
    
            分为2个：一是在标签内写onclick事件
            
            　　　  　  二是在JS写onlicke=function（）{}函数
            　　　  　  
            1）
                <input id="myButton" type="button" value="Press Me" οnclick="alert('thanks');" >
            2）
                document.getElementById("myButton").onclick = function () {
                    alert('thanks');
                }
                
            缺点：会覆盖前面同类型事件    
                
    2级 DOM
            为元素添加监听器，addEventListener，移除方法removeEventListener
            只有2级DOM包含3个事件：事件捕获阶段、处于目标阶段和事件冒泡阶段
            
            缺点：ie不兼容
            
    区别
        如果定义了两个dom0级事件，dom0级事件会覆盖
        dom2不会覆盖，会依次执行
        dom0和dom2可以共存，不互相覆盖，但是dom0之间依然会覆盖
        
#### 33.js的继承方式有哪些
        instanceof 表示是否在同一原型链上
        M.prototype.conctructor===M
    1、原型链继承
        核心：将父类的实例作为子类的原型
        
        function Parent(){
            this.name = 'mike';
        }
    
        function Child(){
            this.age = 12;
        }
        Child.prototype = new Parent();//Child继承Parent，通过原型，形成链条
        
        缺点：1.1 来自原型对象的所有属性被所有实例共享
              1.2 创建子类实例时，无法向父类构造函数传参
              
    2、借用构造函数
        解决了子类实例共享父类引用属性的问题
        创建子类实例时，可以向父类传递参数
        可以实现多继承（call多个父类对象）
        
        function Parent(age){
            this.name = ['mike','jack','smith'];
            this.age = age;
        }
    
        function Child(age){
            Parent.call(this,age);
        }
        
        var test = new Child(21);
        
        缺点：
            2.1 实例并不是父类的实例，只是子类的实例
            2.2 只能继承父类的实例属性和方法，不能继承原型属性/方法
            2.3 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
            
        注：不加 new字 直接调用，this就是指向当前上下文window    
            
    3、组合继承
        使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。
        
        避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为JS中最常用的继承模式。
        
        function Parent (age) {
            this.colors = ["blue","red","green"];
            this.age = age;
        }
        
        Parent.prototype.run = function () {
            return this.colors + ' is ' +this.age;
        }
        function Child (age) {
            Parent.call(this,age);  //对象冒充，给父类型传参
        }
        Child.prototype = new Parent();  //原型链继承
        
        var peter = new Child(20); 
        console.log(peter.run()); //blue,red,green is 20
        
        
            组合式继承的问题
                组合式继承是JS最常用的继承模式，但组合继承的父类型会在使用过程中
                被调用两次，一次是创建子类型的时候，另一次是在子类型构造函数的内部
                
                    function Parent(name){
                        this.name = name;
                        this.arr = ['哥哥','妹妹','父母'];
                    }
                
                    Parent.prototype.run = function () {
                        return this.name;
                    };
                
                    function Child(name,age){
                        Parent.call(this,age);//第二次调用
                        this.age = age;
                    }
                
                    Child.prototype = new Parent();//第一次调用
        
    4、原型式继承
        不自定义类型的情况下，临时创建一个构造函数，借助已有的对象
        作为临时构造函数的原型，然后在此基础实例化对象，并返回。
        
        原型的引用类型属性会在各实例之间共享。
        当只想单纯地让一个对象与另一个对象保持类似的情况下，原型式继承是完全可以胜任的。
        
        本质上是object()对传入其中的对象执行了一次浅复制
        
        function object(o){
         function F(){}
         F.prototype = o;
         return new F();
        }
        
        var person = {
         name: "Nicholas",
         friends: ["Shelby", "Court", "Van"]
        };
        
        var anotherPerson = object(person);
        anotherPerson.name = "Greg";
        anotherPerson.friends.push("Rob");
        
        var yetAnotherPerson = object(person);
        yetAnotherPerson.name = "Linda";
        yetAnotherPerson.friends.push("Barbie");
        
        alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" 
        
        注：ES5 通过新增 Object.create()方法规范化了原型式继承。
        
    5、寄生式继承
        其实就是在原型式继承得到对象的基础上，在内部再以某种方式来增强对象，然后返回。
        
        function create(o){
            var f= obj(o);
            f.run = function () {
                return this.arr;//同样，会共享引用
            };
            return f;
        }
    
    6、寄生组合式继承
        组合继承是JS中最常用的继承模式，但其实它也有不足，组合继承无论什么情况
        下都会调用两次超类型的构造函数，并且创建的每个实例中都要屏蔽超类型对象
        的所有实例属性。
        寄生组合式继承就解决了上述问题，被认为是最理想的继承范式。
        
        function object(o) {
            function F(){}
            F.prototype = o;
            return new F();
        }
        
        function inheritPrototype(superType, subType) {
            var prototype = object(superType.prototype); //相当于拷贝出来的原型副本
            prototype.constructor = subType; //给这拷贝出来的原型副本修改构造函数
            subType.prototype = prototype; //再把子类的原型对象指向原型副本
        }
        
        function SuperType(name) {
            this.name = name;
            this.colors = ["red", "blue", "green"];
        }
        
        SuperType.prototype.sayName = function() {
            alert(this.name);
        };
        
        function SubType(name, age) {
            SuperType.call(this, name);
            this.age = age;
        }
        
        inheritPrototype(SuperType, SubType);   // 这一句，替代了组合继承中的SubType.prototype = new SuperType()
        
        SubType.prototype.sayAge = function() {
            alert(this.age);
        }
        
#### 34. vuex 是什么？怎么使用？哪种功能场景使用它？
        1. vuex ：是一个专为vue.js开发的状态管理器，采用集中式存储的所有组件状态
            五个属性： state、getters、mutations、actions、module
            
               import Vue from 'vue'
               import Vuex from 'vuex'
               Vue.use(Vuex)
               const state = {}
               const getters = {}
               const mutations = {}
               const actions = {}
               export default new Vuex.Store({
                   state,
                   getters,
                   mutations,
                   actions
               
               })
        
            state属性： 存放状态，例如你要存放的数据
            getters： 类似于共享属性，可以通过this.$store.getters来获取存放在state里面的数据
            mutations： 唯一能改变state的状态就是通过提交mutations来改变，this.$store.commit()
            actions: 一步的mutations，可以通过dispatch来分发从而改变state
            
        2.怎么使用
            views 层用户操作 dispatch 触发 action，action 触发 mutation 对状态 state 进行修改。
            state修改后通知相关联组件更新图层
            
            新建vuex的store实例，配置好属性，然后挂载到vue的根实例
        
        3.有什么用？使用场景？
        
            场景一：处理多组件依赖于同一个数据，例如有柱状图和条形图两个组件都是展示的同一数据；
            
            场景二： 一个组件的行为——改变数据——影响另一个组件的视图，其实也就是公用依赖的数据；
            
            Vuex将组件公用数据抽离，在一个公共仓库管理，使得各个组件容易获取（getter）数据，也容易设置数据（setter）。
            
        4.分模块开发
            export default new Vuex.Store({
              modules: {
                app,
                errorLog,
                permission,
                tagsView,
                user,
                callsys,
                webSocketData
              },
              getters
            })
            
        const getters = {
              sidebar: state => state.app.sidebar,
              language: state => state.app.language,
              device: state => state.app.device    
        }    
#### 35.js常用设计模式
    1.工厂模式
        产生大量相似的商品，去做同样的事情，实现同样的效果;
        可以理解为解决多个相似的问题。
        
        工厂模式根据抽象程度的不同可以分为：简单工厂，工厂方法和抽象工厂
        
        1.1 简单工厂模式
            简单工厂模式又叫静态工厂模式，由一个工厂对象决定创建某一种产品对象类的实例。
            主要用来创建同一类对象。
            
            简单工厂只能作用于创建的对象数量较少，对象的创建逻辑不复杂时使用
            
            let UserFactory = function (role) {
              function User(opt) {
                this.name = opt.name;
                this.viewPage = opt.viewPage;
              }
            
              switch (role) {
                case 'superAdmin':
                  return new User({ name: '超级管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据', '权限管理'] });
                  break;
                case 'admin':
                  return new User({ name: '管理员', viewPage: ['首页', '通讯录', '发现页', '应用数据'] });
                  break;
                case 'user':
                  return new User({ name: '普通用户', viewPage: ['首页', '通讯录', '发现页'] });
                  break;
                default:
                  throw new Error('参数错误, 可选参数:superAdmin、admin、user')
              }
            }
            
            //调用
            let superAdmin = UserFactory('superAdmin');
            
        1.2 工厂方法模式
            工厂方法模式的本意是将实际创建对象的工作推迟到子类中，这样核心类就变成了抽象类。
            看作是一个实例化对象的工厂类
            
            //安全模式创建的工厂方法函数
            let UserFactory = function(role) {
              if(this instanceof UserFactory) {
                var s = new this[role]();
                return s;
              } else {
                return new UserFactory(role);
              }
            }
            
            //工厂方法函数的原型中设置所有对象的构造函数
            UserFactory.prototype = {
              SuperAdmin: function() {
                this.name = "超级管理员",
              },
              Admin: function() {
                this.name = "管理员",
              },
              NormalUser: function() {
                this.name = '普通用户',
              }
            }
            
            //调用
            let superAdmin = UserFactory('SuperAdmin');
            
        1.3 抽象工厂
            抽象工厂实际上是一个实现子类继承父类的，在这个
            方法中需要传递子类以及要继承父类的名称，并且在
            抽象工厂方法中增加了一次对抽象类存在性的一次判
            断，如果存在，则将子类继承父类的方法，然后子类
            通过寄生式继承。
    
    
    
    2.单例模式    
        单例模式的定义：保证一个类仅有一个实例，并提供一个访问它的全局访问点。
        实现的方法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建
        了再返回，这就确保了一个类只有一个实例对象。
        
        单例模式的优点是：
        
            可以用来划分命名空间，减少全局变量的数量。
            使用单体模式可以使代码组织的更为一致，使代码容易阅读和维护。
            可以被实例化，且实例化一次。
        
        适用场景：一个单一对象。比如：弹窗，无论点击多少次，弹窗只应该被创建一次。
        
        class CreateUser {
            constructor(name) {
                this.name = name;
                this.getName();
            }
            getName() {
                 return this.name;
            }
        }
        
        // 代理实现单例模式
        var ProxyMode = (function() {
            var instance = null;
            return function(name) {
                if(!instance) {
                    instance = new CreateUser(name);
                }
                return instance;
            }
        })()
        
        // 测试单体模式的实例
        var a = new ProxyMode("aaa");
        var b = new ProxyMode("bbb");
        
        // 因为单体模式是只实例化一次，所以下面的实例是相等的
        console.log(a === b);    //true
    
    3.发布订阅模式
        又叫观察者模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，
        当一个对象发生改变时，所有依赖于它的对象都将得到通知。
        
        发布订阅模式的优点：
             1. 支持简单的广播通信，当对象状态发生改变时，会自动通知已经订阅过的对象。
             2. 大大降低程序模块之间的耦合度，便于更加灵活的扩展和维护。
             
        发布订阅模式的缺点：
        
          创建订阅者需要消耗一定的时间和内存。
          虽然可以弱化对象之间的联系，如果过度使用的话，反而使代码不好理解及代码不好维护等等。     
        
        
        var shoeObj = {}; // 定义发布者
        shoeObj.list = []; // 缓存列表 存放订阅者回调函数
                
        // 增加订阅者
        shoeObj.listen = function(fn) {
            shoeObj.list.push(fn);  // 订阅消息添加到缓存列表
        }
         
        // 发布消息
        shoeObj.trigger = function(){
            for(var i = 0,fn; fn = this.list[i++];) {
                fn.apply(this,arguments); 
            }
        }
        // 小红订阅如下消息
        shoeObj.listen(function(color,size){
            console.log("颜色是："+color);
            console.log("尺码是："+size);  
        });
         
        // 小花订阅如下消息
        shoeObj.listen(function(color,size){
            console.log("再次打印颜色是："+color);
            console.log("再次打印尺码是："+size); 
        });
        shoeObj.trigger("红色",40);
    
    4.策略模式
        策略模式的定义：定义一系列的算法，把他们一个个封装起来，并且使他们可以相互替换
        
        优点：1. 策略模式利用组合，委托等技术和思想，有效的避免很多if条件语句。
              2. 策略模式提供了开放-封闭原则，使代码更容易理解和扩展。
              3. 策略模式中的代码可以复用。
        
        缺点：1.增加许多策略类或者策略对象，但实际上这比把它们负责的 逻辑堆砌在 Context 中要好。
              2.必须了解所有的策略类之间的不同点，这样才能选择一个合适的 strategy。
              
        Javascript版本的策略模式
        
        var obj = {
                "A": function(salary) {
                    return salary * 4;
                },
                "B" : function(salary) {
                    return salary * 3;
                },
                "C" : function(salary) {
                    return salary * 2;
                } 
        };
        var calculateBouns =function(level,salary) {
            return obj[level](salary);
        };
        console.log(calculateBouns('A',10000));
        
    5.代理模式
        
        代理模式的定义：为一个对象提供一个代用品或占位符，以便控制对它的访问。
    
        常用的虚拟代理形式：某一个花销很大的操作，可以通过虚
        拟代理的方式延迟到这种需要它的时候才去创建
        （例：使用虚拟代理实现图片懒加载）
        
        图片懒加载的方式：先通过一张loading图占位，然后通过异步
        的方式加载图片，等图片加载好了再把完成的图片加载到img标签里面。
        
        场景：图片懒加载，函数节流，还有缓存代理
        
        优点：减少性能或者网络上的开销
        
    6.中介者模式
        中介者模式的定义：所有的相关对象都通过中介者对象来通信，而不是互相
        引用，所以当一个对象发生改变时，只需要通知中介者对象即可。
        
        适用的场景：例如购物车需求，存在商品选择表单、颜色选择表单、购买数
        量表单等等，都会触发change事件，那么可以通过中介者来转发处理这些事
        件，实现各个事件间的解耦，仅仅维护中介者对象即可。
        
        核心：使网状的多对多关系变成了相对简单的一对多关系（复杂的调度处理都交给中介者）
        
        使用中介者模式的优点：
            优点：可以减少对象间的引用，达到解耦的效果，维护简单
            
        使用中介者模式的缺点：
            
            中介者模式的缺点是显而易见的，因为这个“中介“承担了较多的责任，所以一旦这个中介对象出现了问题，那么整个系统就会受到重大的影响。
        
    7.装饰者模式
        装饰者模式的定义：在不改变对象自身的基础上，在程序
        运行期间给对象动态地添加方法。
        
        装饰者模式适用的场景：原有方法维持不变，在原有方法上
        再挂载其他方法来满足现有需求；函数的解耦，将函数拆分
        成多个可复用的函数，再将拆分出来的函数挂载到某个函数上，
        实现相同的效果但增强了复用性。
        
#### 36.<keep-alive></keep-alive>的作用是什么?
    keep-alive是Vue提供的一个抽象组件，用来对组件进行缓存，不会重复渲
    染该组件从而节省性能，由于是一个抽象组件，所以在页面渲染完毕后不
    会被渲染成一个DOM元素
    
    keep-alive提供两个属性 include和exclude，include表示哪些页面需要缓存，
    exclude表示哪些页面不需要缓存，参数是用逗号分隔字符串、正则表达式或
    一个数组，为各组件的name值
    
        <keep-alive include="a,b"></keep-alive>
        <keep-alive :include="/a|b/"></keep-alive>
    
    被包含在 中创建的组件，会多出两个生命周期的钩子: activated 与 deactivated
    
    activated:在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用。
    
    deactivated:在组件被停用时调用。
    
    一般配合router-view使用，缓存路由页面
    
    需要注意的地方:
        1. <keep-alive> 先匹配被包含组件的 name 字段，如果 name 不可用，则匹配当前组件 components 配置中的注册名称。
        2. <keep-alive> 不会在函数式组件中正常工作，因为它们没有缓存实例。
        3. 当匹配条件同时在 include 与 exclude 存在时，以 exclude 优先级最高(当前vue 2.4.2 version)。比如：包含于排除同时匹配到了组件A，那组件A不会被缓存。
        4. 只有被包裹的组件才有这两个生命周期, 但符合 exclude ，也不会有activated 和 deactivated。
        5. include和exclude参数值当使用正则或者是数组时，一定要使用 v-bind 

#### 37.vue路由传参的三种方式
    1.params传参（url中显示参数）
    
        路由写法：path: "/one/login/:num" 
        
        跳转的组件 <router-link to="/one/login/001">
        
        子路由获取的参数： this.$route.params.num
        
    2.params传参（url中不显示参数）
        html：
        <router-link :to="{name:'Log',params:{num:666}}">显示登录页面</router-link>
        
        js：
            this.$router.push({
              name: 'Describe',
              params: {
                id: id
              }
            })
        
        子路由获取的参数： this.$route.params.num
        
    3.通过query来传递参数
        this.$router.push({
          path: '/describe',
          query: {
            id: id
          }
        })
        
        <router-link :to="{path:'/one/log',query:{num:123}}">显示登录页面</router-link>
        
        path:'/one/log?num=123'
        
        子路由获取参数：this.$route.query.num
        
#### 38. diff算法
    diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁(patch)。
    
    在采取diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。
    
    diff对比就是vnode的对比
    
    1.vdom为何用diff算法
    
        1.1 DOM操作是昂贵的，因此尽量减少DOM操作
        1.2 找出本次DOM必须更新的节点来更新，其他的不更新
        1.3 这个‘找出’的过程，就需要diff算法
        
    2.vdom是什么
        虚拟dom，将真实dom抽出来，以对象形式模拟树形结构
        <div>
            <p>JS每日一题</p>
        </div>
        
        // 转换成VNode 类似于下面这种
        
        const Vnode = {
            tag: 'div',
            children: [
                { tag: 'p', text: 'JS每日一题' }
            ]
        };
        
    3.diff 是如何比较的?
        简单的说就是新旧虚拟dom 的比较，如果有差异就以新的为准，然后再插入的真实的dom中，重新渲染
        
    4.key的作用
        设置key和不设置key的区别：
            不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，
            还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效
            的利用dom
            
            key的作用主要是为了高效的更新虚拟DOM
            
    5.vdom比较过程
        function patch (oldVnode, vnode) {
            if (sameVnode(oldVnode, vnode)) {
                patchVnode(oldVnode, vnode)
            } else {
                const oEl = oldVnode.el
                let parentEle = api.parentNode(oEl)
                createEle(vnode)
                if (parentEle !== null) {
                    api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))
                    api.removeChild(parentEle, oldVnode.el)
                    oldVnode = null
                }
            }
            return vnode
        }
        
    第一步，sameVnode判断新旧节点是否值得去比较
    
    function sameVnode(oldVnode, vnode){
        return vnode.key === oldVnode.key && vnode.sel === oldVnode.sel
    }
    
    当不值得比较时，旧节点移除，新节点插入，然后返回vnode
    
    当两节点值得比较时，调用patchVnode函数
    
    patchVnode (oldVnode, vnode) {
        const el = vnode.el = oldVnode.el
        let i, oldCh = oldVnode.children, ch = vnode.children
        if (oldVnode === vnode) return
        if (oldVnode.text !== null && vnode.text !== null && oldVnode.text !== vnode.text) {
            api.setTextContent(el, vnode.text)
        }else {
            updateEle(el, vnode, oldVnode)
            if (oldCh && ch && oldCh !== ch) {
                updateChildren(el, oldCh, ch)
            }else if (ch){
                createEle(vnode) //create el's children dom
            }else if (oldCh){
                api.removeChildren(el)
            }
        }
    }
    
    patchVnode函数判断有五种情况
        1、引用的节点相同
        2、文本节点不一样，则Node.textContent = vnode.text，采用新文本节点
        3、同时有子节点，且子节点不一样，调用updateChildren比较子节点，是diff的核心
        4、老节点没有子节点，新节点有子节点，在老dom节点上添加子节点
        5、老节点有子节点，新节点没有子节点，把老dom节点上的子节点移除
        
    
    调用updateChildren函数
        1、将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来
        2、oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。
        如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，
        一旦StartIdx>EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。
        当两个节点存在比较价值，就会递归调用patchVnode，
        就这样层层递归下去，直到将oldVnode和Vnode中的所有子节点比对完。
        
#### 39.vue开发遇到的问题
    1.安卓手机上真机测试白屏的问题解决
        主要是因为有些安卓手机浏览器不支持promise，可以引入一个插件来解决。
        
        cnpm install babel-polyfill --save
        
        在main.js里面引入
        import ‘babel-polyfill’
        
    2.给组件增加独有样式
        vue中每一个组件都可以自定各自的css样式，如果希望组件内的样式只对当前组件起作用，可以在style标签中增加scoped即可。
        会让vue在渲染组件的时候给每个元素都增加一个data-v-/版本号/的属性
        
    3. 引用图片    
        在js里引用静态图片，动态引用图片时，引用不到。
        因为放在template模板里会被webpack打包所以可以，而放
        在data或者动态赋值，图片路径只是一个字符串webpack不
        会处理所以引用不到。
        
        解决办法：通过import或者required引入。
        import src from ‘../../img.png’或者data:{img:require(‘../../img.png’)}
        
#### 40.webpack的实现原理及配基本配置
    1.实现原理
        webpack只是一个打包模块的机制，只是把依赖的模块转化成可以代表这些包的静态文件。
        webpack就是识别你的 入口文件。识别你的模块依赖，递归地构建一个依赖关系图，来打包你的代码。
        webpack做的就是分析代码，转换代码，编译代码，输出代码。webpack本身是一个node的模块，
        所以webpack.config.js是以commonjs形式书写的(node中的模块化是commonjs规范的)
        
        webpack中每个模块有一个唯一的id，是从0开始递增的。整个打包后的bundle.js是一个匿名函
        数自执行。参数则为一个数组。数组的每一项都为个function。function的内容则为每个模块
        的内容，并按照require的顺序排列。
        
        1.1 webpack拥有五个核心概念：
                入口(entry)：入口文件，webpack构建第一步从entry开始
                Module：模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从
                配置的 Entry 开始递归找出所有依赖的模块。
                Chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。
                loader：模块转换器，用于将模块的原内容按照需求转换成新内容
                插件(plugins)：拓展插件，在webpack构建流程中的特定时机会广播对应的事件，插件
                可以监听这些事件的发生，在特定的时机做对应的事情
            
        1.2 流程概述
           webpack从启动到结束依次执行以下操作：
            初始化参数 --> 开始编译 -->确定入口 --> 编译模块 --> 完成编译模块 --> 输出资源 --> 输出完成
            
            各个阶段执行的操作如下：
            
                1.初始化参数：从配置文件(默认webpack.config.js)和shell语句中读取与合并参数，
                得出最终的参数
                2.开始编译(compile)：用上一步得到的参数初始化Comiler对象，加载所有配置的插件，
                通过执行对象的run方法开始执行编译
                3.确定入口：根据配置中的entry找出所有的入口文件
                4.编译模块：从入口文件出发，调用所有配置的Loader对模块进行翻译,再找出该模块
                依赖的模块，再递归本步骤直到所有入口依赖的文件都经过处理
                5.完成编译模块：经过第四步之后，得到了每个模块被翻译之后的最终内容以及他们之间的依赖关系
                6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的chunk，再将
                每个chunk转换成一个单独的文件加入输出列表中，这是可以修改输出内容的最后机会
                7.输出完成：在确定好输出内容后，根据配置(webpack.config.js && shell)确定输出的路
                径和文件名，将文件的内容写入文件系统中(fs)
                8.在以上过程中，webpack会在特定的时间点广播特定的事件，插件监听事件并执行相应的逻
                辑，并且插件可以调用webpack提供的api改变webpack的运行结果
        
        1.3 流程细节
            webpack构建流程可分为以下三大阶段。
            
                初始化：启动构建，读取与合并配置参数，加载plugin,实例化Compiler
                编译：从Entry出发，针对每个Module串行调用对应的Loader去翻译文件中的内容，再找到该Module依赖的Module，递归的进行编译处理
                输出：将编译后的Module组合成Chunk,将Chunk转换成文件，输出到文件系统中
                
                如果只执行一次，流程如上，但在开启监听模式下，流程如下图
                
                  初始化-->编译;
                  编译-->输出;
                  输出-->文本发生变化
                  文本发生变化-->编译
        
        1.4 主要解决问题        
            1.文件依赖管理 梳理文件之间的依赖关系
            2.资源加载管理 处理文件的加载顺序（先后时机）和文件的加载数量（合并、嵌入、拆分）
            3.效率与优化管理 提高开发效率，完成页面优化
    
    2.基本配置
        注意：__dirname 总是指向被执行 js 文件的绝对路径， /d1/d2/myscript.js 写了 __dirname，表示/d1/d2 。
            path.resolve([from...],to)，相当于执行cd操作。
        
        var path = require('path');
        
        module.exports = {
          // 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。
          entry: {
            app: './src/main.js'
          },
          // 多入口写法
          entry:{
              app:'./src/main.js',
              app2:'./src/main.js'
          }
          //多入口对应多出口
          output:{
              path:......,
              filename:'[name].js'
          }
          
          // 文件路径指向(可加快打包过程)。
          resolve: {
            alias: {
              'react': pathToReact
            }
          },
          // 生成文件，是模块构建的终点，包括输出文件与输出路径。
          output: {
            // path.resolve用来拼接文件多级目录
            // __dirname 为当前文件所在全路径地址
            path: path.resolve(__dirname,'dist'), 
            // 输出文件名字
            // filename: 'app.js', 
            // 以key作为文件名输出
            filename: '[name].js',
            // chunkhash 根据文件内容生成特点的hash，使用这个可以保证文件内容不变，那么文件名字就不会改变，可以用来作为热更新
            chunkFilename: '[chunkhash].js'
          },
          resolve:{
                extensions:['','.css','.js','jsx']
          },
          // 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。
          module: {
            rules: [
              {
                test: /\.js$/,
                loader: 'babel',
                query: {
                  presets: ['es2015', 'react']
                }
              }
            ]
          },
          // webpack 各插件对象，在 webpack 的事件流中执行对应的方法。
          plugins: [
            new webpack.HotModuleReplacementPlugin()
          ]
        };
        
        modules
            babel-loader(用来做js代码转化)
            style-loader & css-loader(用来转化css代码)
            less-loader 转化less文件
            file-loader: fileload 指定一类对象作为文件，并且返回一个public 的url，这样可以利用浏览器的线程来加载文件，减小bundle.js的大小。
            url-loader: url-loader 使用limit来指定一个size，当文件的大小小于这个size的时候，对象将会转化为Dataurl，直接嵌入在js中.
            
        resolve.extensions详细说明
    　　　　（1）resolve.extensions并不是必须配置的，当不配置时，会使用默认值
    　　　　         ["", ".webpack.js", ".web.js", ".js"]，当手动为resolve.extensions设置值，
    　　　      　  它的默认值会被覆盖
    　　　　（2）如果你想要每个模块都能够按照它们自己扩展名正确的被解析，要在数组中添加一个空字符串。
    　　　　（3）如果你想请求一个js文件但是在请求时不带扩展（如：require('somecode')）,那么就需要
    　　　　将'.js'添加到数组中。其他文件一样    
    　　　　
    3.loaders顺序
        loaders顺序是从下往上 ，从右往左编译，
        编译完后把原文传给下一个loaders，所以
        有些loader需要按顺序排列
        
    4.CommonsChunkPlugin
        CommonsChunkPlugin主要是用来提取第三方库和公共模块
        
        第三方库单独打包成一个文件，配置单独的入口
        entry: {
            vendor: ['vue', 'vue-router', './public/vendor/jquery/jquery']
        },
        
        new webpack.optimize.CommonsChunkPlugin('vendor');
        
        const path = require("path");
        const webpack = require("webpack");
        const packagejson = require("./package.json");
        
        const config = {
            entry: {
                first: './src/first.js',
                second: './src/second.js',
                vendor: Object.keys(packagejson.dependencies)//获取生产环境依赖的库
            },
            output: {
                path: path.resolve(__dirname,'./dist'),
                filename: '[name].js'
            },
            plugins: [
                new webpack.optimize.CommonsChunkPlugin({
                    name: 'vendor',
                    filename: '[name].js'
                }),
            ]
        }
        
        module.exports = config;
        
        注：Object.keys()返回可枚举属性组成的数组 Object.keys(obj)
        
        单独分离出第三方库、自定义公共模块、业务模块、webpack运行文件可以优化前端页面，
        每次更改业务文件就不需要全部重新部署，用户也不用重新加载所有文件
        
        1.. 抽离webpack运行文件
        
            plugins: [
                new webpack.optimize.CommonsChunkPlugin({
                    name: ['vendor','runtime'],
                    filename: '[name].js'
                }),
            ]
            抽离出了webpack运行时文件
            
        2.. 抽离第三方库和自定义公共模块
            想将vendor仅仅为第三方库，不包含自定义公共模块，引入minChunks
            
            CommonsChunkPlugin可配置的属性：
                name：可以是已经存在的chunk（一般指入口文件）对应的name，那么就会把公共模块代码合并到这个chunk上；否则，会创建名字为name的commons chunk进行合并
                filename：指定commons chunk的文件名
                chunks：指定source chunk，即指定从哪些chunk当中去找公共模块，省略该选项的时候，默认就是entry chunks
                minChunks：既可以是数字，也可以是函数，还可以是Infinity，具体用法和区别下面会说
                        数字：模块被多少个chunk公共引用才被抽取出来成为commons chunk
                        函数：接受 (module, count) 两个参数，返回一个布尔值，你可以在函数内进行你规定好的逻辑来决定某个模块是否提取成为commons chunk
                        Infinity：只有当入口文件（entry chunks） >= 3 才生效，用来在第三方库中分离自定义的公共模块
                        
            第一种方法minChunks设为Infinity：
                plugins: [
                    new webpack.optimize.CommonsChunkPlugin({
                        name: ['vendor','runtime'],
                        filename: '[name].js',
                        minChunks: Infinity
                    }),
                    new webpack.optimize.CommonsChunkPlugin({
                        name: 'common',
                        filename: '[name].js',
                        chunks: ['first','second']//从first.js和second.js中抽取commons chunk
                    }),
                ]
                这时候的vendor.js就纯白无瑕，只包含第三方库文件，common.js就是自定义的公共模块，runtime.js就是webpack的运行文件。
                
            第二种方法把它们分离开来，就是利用minChunks作为函数的时候：
            
                minChunks作为函数两个参数的含义：
                    module：当前chunk及其包含的模块
                    count：当前chunk及其包含的模块被引用的次数
                    
                minChunks作为函数会遍历每一个入口文件及其依赖的模块，返回一个布尔值，
                为true代表当前正在处理的文件（module.resource）合并到commons chunk中，为false则不合并。
                
                const config = {
                    entry: {
                        first: './src/first.js',
                        second: './src/second.js',
                        //vendor: Object.keys(packagejson.dependencies)//获取生产环境依赖的库
                    },
                    output: {
                        path: path.resolve(__dirname,'./dist'),
                        filename: '[name].js'
                    },
                     plugins: [
                        new webpack.optimize.CommonsChunkPlugin({
                            name: 'vendor',
                            filename: '[name].js',
                            minChunks: function (module,count) {
                                console.log(module.resource,`引用次数${count}`);
                                //"有正在处理文件" + "这个文件是 .js 后缀" + "这个文件是在 node_modules 中"
                                return (
                                    module.resource &&
                                    /\.js$/.test(module.resource) &&
                                    module.resource.indexOf(path.join(__dirname, './node_modules')) === 0
                                )
                            }
                        }),
                        new webpack.optimize.CommonsChunkPlugin({
                            name: 'runtime',
                            filename: '[name].js',
                            chunks: ['vendor']
                        }),
                    ]
                }
                
                这样只要有js文件在node_modules就会加入到vendor中，其实这也是一种让vendor只保留第三方库的办法。
                
        3.. children和async属性
            这两个属性主要是在code split（代码分割）和异步加载当中应用。
            
                children
                
                    1.指定为true的时候，就代表source chunks是通过entry chunks（入口文件）进行code split出来的children chunks
                    2.children和chunks不能同时设置，因为它们都是指定source chunks的
                    3.children 可以用来把 entry chunk 创建的 children chunks 的共用模块合并到自身，但这会导致初始加载时间较长
                    
                async：即解决children:true时合并到entry chunks自身时初始加载时间过长的问题。
                       async设为true时，commons chunk 将不会合并到自身，而是使用一个新的异
                       步的commons chunk。当这个children chunk 被下载时，自动并行下载该commons chunk
            
            增加chunkFilename
            output: {
                    ...........
                    chunkFilename: "[name].[hash:5].chunk.js",
                },
            plugins: [
                new webpack.optimize.CommonsChunkPlugin({
                    name: ['vendor','runtime'],
                    filename: '[name].js',
                    minChunks: Infinity
                }),
               new webpack.optimize.CommonsChunkPlugin({
                    children: true,
                    async: 'children-async'
                })
            ]
        
        4.. 浏览器缓存的实现
            哈希值的不同：
                hash 是 build-specific ，即每次编译都不同——适用于开发阶段
                chunkhash 是 chunk-specific，是根据每个 chunk 的内容计算出的 hash——适用于生产
                所以，在生产环境，要把文件名改成'[name].[chunkhash]'，最大限度的利用浏览器缓存。
                
        
        webpack4已经把CommonsChunkPlugin插件去掉了，它使用内置API optimization.splitChunks 和
        optimization.runtimeChunk ，这意味着webpack会默认为你生成共享的代码块。
        
            
    
    5.修改上下文        
        由于项目的webpack.config.js文件不一定在项目的根目录，
        但是需要上下文在根目录中，可以使用context修改
        
        module.exports = {
            entry: ‘./A.js‘,
            context: path.join(__dirname, ‘..‘), // 返回绝对路径
            output: {
                filename: ‘./bundle.js‘
            }
        }
        
        在根目录运行webpack时，则需要指定配置文件：webpack --config config/webpack.config.js
        
        注：path.resolve相当于从左到右cd，path.join是拼接路径
        
        
#### 41.怎么解决浏览器兼容性问题
    1. BFC解决边距重叠问题
        当相邻元素都设置了 margin 边距时，margin 将取最大值，舍弃小值。
        为了不让边距重叠，可以给子元素加一个父元素，并设置该父元素
        为 BFC：overflow: hidden;
        <div class="box" id="box">
          <p>Lorem ipsum dolor sit.</p>
        
          <div style="overflow: hidden;">
            <p>Lorem ipsum dolor sit.</p>
          </div>
        
          <p>Lorem ipsum dolor sit.</p>
        </div>
    
    注：BFC 块级格式化上下文
        Box：css布局的基本单位
        Formatting Context:Formatting context 是 W3C CSS2.1 规范中的一个概念。
        它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何
        定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有
        Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。
        
        Box 是 CSS 布局的对象和基本单位， 就是一个页面是由很多个 Box 组成的。
        元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box会
        以不同的方式渲染。
            block-level box:display:block, 块状元素
            inline-level box:display: inline 行内元素
            run-in box: css3 中才有， 这儿先不讲了。
        
        Formatting context 是页面中的一块渲染区域，并且有一套渲染规则，它决定
        了其子元素将如何定位，以及和其他元素的关系和相互作用。
        最常见的 Formatting context 有 
        Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。
        
        
        BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，
        块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。
        
        BFC的布局规则
            1.内部的Box会在垂直方向，一个接一个地放置，box分为块盒和行盒，行盒为一行内所有内联元素
            2.Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。
            3.每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
            4.BFC的区域不会与float box重叠。
            5.BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。
            6.计算BFC的高度时，浮动元素也参与计算。
            
        如何创建BFC
            1、float的值不是none。
            2、position的值不是static或者relative。
            3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex, 非块级容器
            4、overflow的值不是visible
            
        BFC的作用
            1.利用BFC避免margin重叠：因为相邻元素的margin会重叠，激活为bfc就不会重叠，添加overflow:hidden
            2.自适应两栏布局：左元素设置浮动，右元素设置bfc，由于bfc不会与floatbox重叠，右元素会自适应，不与左元素重叠
            3.清楚浮动：子元素浮动，父元素失去高度，给父元素添加overflow:hidden, 会计算浮动元素高度，将父元素撑起
            
    2.浏览器 CSS 兼容前缀
    
    3.a标签各种伪类没效果
        需按照以下顺序写
            link:平常的状态
            visited:被访问过之后
            hover:鼠标放到链接上的时候
            active:链接被按下的时候
            
    4.完美解决placeholder
        <input type="text" value="Name *" onFocus="this.value = '';" onBlur="if (this.value == '') {this.value = 'Name *';}">
        
    5.各浏览器各标签的padding和margin都不同
        * {padding:0;margin:0}解决
        
    6.块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
        问题症状:常见症状是IE6中后面的一块被顶到下一行
        解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性
        
#### 44.js进阶问题列表
    1.new Number(3) === 3  //false
        new Number() 是一个内建的函数构造器。虽然它看着像是一个 number，
        但它实际上并不是一个真实的 number：它有一堆额外的功能并且它是一个对象。
      
      new String() 也是
      
      但是数组和对象无论是=== 还是== 都为false，就算两个[]以为false，因为[]其实是
      个对象，有不同的内存地址，所以不相等
    
    2.class static关键字
        如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。
        
        class Foo {
          static classMethod() {
            this.baz()
            return 'hello';
          }
          
          static baz () {
            console.log('类baz');
          }
          baz () {
            console.log('实例baz');
          }
        }
        
        Foo.classMethod() // '类baz', 'hello'  静态方法可以在类上调用
        
        var foo = new Foo();
        foo.classMethod() //报错，实例不能调用静态方法
        
        静态方法和非静态可以重名
        注意：如果静态方法包含this关键字，这个this指的是类，而不是实例
        
    3. 没用new创建的构建函数 
        function Person(firstName) {
          this.firstName = firstName
        }
        const sarah = Person('Sarah')
        console.log(sarah) //undefined   
        
    4.标签模板字面量
        function foo(strings,...values){
            console.log(strings)
            console.log(values)
        }
        const desc='awesome'
        foo`Everything is ${desc}!]`;
        // ["Everything is ","!"]
        // ["awesome"]
        
        function getPersonInfo(one, two, three) {
          console.log(one)
          console.log(two)
          console.log(three)
        }
        
        const person = 'Lydia'
        const age = 21
        
        getPersonInfo`${person} is ${age} years old` //["", " is ", " years old"] "Lydia" 21
        
    5.数组typeof object
        typeof 返回值有六种可能： "number," "string," "boolean," "object," "function," 和 "undefined."以及'symbol'
        
        array，null，object都是object
    
    6.对象字符串化会成为'[object object]'
        const a = {}
        const b = { key: 'b' }
        const c = { key: 'c' }
        
        a[b] = 123
        a[c] = 456
        
        console.log(a[b]) //456
        
        当字符串化一个对象时，它会变成 "[object Object]"。因此这里说的是，a["[object Object]"] = 123
        
    7.冒泡时，event.target指向哪个元素
        嵌套最深的那个元素
    
    8.当您单击该段落时，日志输出是什么？
        <div onclick="console.log('div')">
          <p onclick="console.log('p')">
            Click here!
          </p>
        </div>
        
        p div
        
        虽然事件传播顺序是捕获、目标和冒泡，但是一般事件在冒泡阶段执行，除非将 useCapture 设置为 true
        所以按冒泡顺序执行
    
    9.数组空的位置为？
        var a = [1,2]
        a[5] = 6
        
        a // [1,2,3 x empty,6]
        
    10.JavaScript 只有基本类型和对象。
        基本类型7种boolean, null, undefined, bigint, number, string, symbol。
        
    11.reduce
        [[0, 1], [2, 3]].reduce(
          (acc, cur) => {
            return acc.concat(cur)
          },
          [1, 2]
        )
        
        [1, 2]是初始值。初始值将会作为首次调用时第一个参数 acc 的值。
        在第一次执行时， acc 的值是 [1, 2]， cur 的值是 [0, 1]。合并
        它们，结果为 [1, 2, 0, 1]。 第二次执行， acc 的值是 [1, 2, 0, 1]， 
        cur 的值是 [2, 3]。合并它们，最终结果为 [1, 2, 0, 1, 2, 3]
        
    12.setInterval 方法的返回值是什么？
        setInterval 返回一个唯一的 id。此 id 可被用于 clearInterval 函数来取消定时。
        
    13.扩展运算符
        [...'Lydia']
        ["L", "y", "d", "i", "a"]
        
    14.Promise.race
        顾名思义，Promse.race就是赛跑的意思，意思就是说，
        Promise.race([p1, p2, p3])里面哪个结果获得的快，
        就返回那个结果，不管结果本身是成功状态还是失败状态。
        
        const firstPromise = new Promise((res, rej) => {
          setTimeout(res, 500, "one");
        });
        
        const secondPromise = new Promise((res, rej) => {
          setTimeout(res, 100, "two");
        });
        
        Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
        
        "two"
    
    15.赋值和引用
        let person = { name: "Lydia" };
        const members = [person];
        person = null;
        
        console.log(members); //[{ name: "Lydia" }]
        
        当你将引用从一个变量分配至另一个变量时，其实只是执行了一个 复制 操作。
        我们没有修改数组第一个元素的值，而只是修改了变量person的值,因为元素
        （复制而来）的引用与person不同。members的第一个元素仍然保持着对原始
        对象的引用。当我们输出members数组时，第一个元素会将引用的对象打印出来。
        
    16.parseInt解析过程
        const num = parseInt("7*6", 10); //7   
        只返回了字符串中第一个字母. 设定了 进制 后 (也就是第二个参数，指定
        需要解析的数字是什么进制: 十进制、十六机制、八进制、二进制等等……),
        parseInt 检查字符串中的字符是否合法. 一旦遇到一个在指定进制中不合
        法的字符后，立即停止解析并且忽略后面所有的字符。
        *就是不合法的数字字符。所以只解析到"7"，并将其解析为十进制的7. num的值即为7.
        
    17.函数参数传值
        function getInfo(member, year) {
          member.name = "Lydia";
          year = "1998";
        }
        
        const person = { name: "Sarah" };
        const birthYear = "1997";
        
        getInfo(person, birthYear);
        
        console.log(person, birthYear); //{ name: "Lydia" }, "1997"
        
        普通参数都是 值 传递的，而对象则不同，是 引用 传递。所以说，birthYear是值传递，因为他是个字符串而不是对象。当我们对参数进行值传递时，会创建一份该值的复制。
        变量birthYear有一个对"1997"的引用，而传入的参数也有一个对"1997"的引用，但二者的引用并不相同。当我们通过给 year赋值"1998"来更新year的值的时候我们只是更新了year（的引用）。此时birthYear仍然是"1997".
        而person是个对象。参数member引用与之 相同的 对象。当我们修改member所引用对象的属性时,person的相应属性也
        被修改了,因为他们引用了相同的对象. person的 name属性也变成了 "Lydia".
    
    18.throw 
        通过throw语句，我么可以创建自定义错误。 而通过它，我们可以抛出异常。
        异常可以是一个字符串, 一个 数字, 一个 布尔类型 或者是一个 对象。
        
    19.
        function Car() {
          this.make = "Lamborghini";
          return { make: "Maserati" };
        }
        
        const myCar = new Car();
        console.log(myCar.make);    //"Maserati"
        
    20.引入模块不能被修改
        let counter = 10;
        export default counter;
        
        import myCounter from "./counter";
        
        myCounter += 1;
        
        console.log(myCounter);//Error
        
    21.delete操作符
        delete操作符返回一个布尔值： true指删除成功，
        否则返回false. 但是通过 var, const 或 let 关
        键字声明的变量无法用 delete 操作符来删除。
        
    22.Object.key()
        Object.keys方法仅返回对象中 可枚举(enumerable) 的属性，因此只剩下了"name".
        以数组形式返回
        
    23.JSON.stringify(value[, replacer [, space]])
        value
            将要序列化成 一个JSON 字符串的值。
        
        replacer 可选
            如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会
            经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组
            中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者
            未提供，则对象所有的属性都会被序列化；关于该参数更详细的解释和示例，
            请参考使用原生的 JSON 对象一文。
        
        space 可选
            指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个
            数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；
            如果该参数为字符串(字符串的前十个字母)，该字符串将被作为空格；如果
            该参数没有提供（或者为null）将没有空格。
        
        返回值
            一个表示给定值的JSON字符串。
            
    24.箭头函数
        箭头函数有两种格式：
            1，只包含一个表达式，可以省略{ … }和return
            2，包含多条语句，这时候就不能省略{ … }和return：
            
    25.reduce 
        arr.reduce(function(prev,cur,index,arr){
            ...
        }, init);
        
        arr 表示原数组；
        prev 表示上一次调用回调时的返回值，若有init则初始值为init，没有则为数组第一个元素;
        cur 表示当前正在处理的数组元素；
        index 表示当前正在处理的数组元素的索引，若提供 init 值，则索引为0，否则索引为1；
        init 表示初始值。非必要参数
        
        回调函数return的值作为prev，reduce返回的是一个数组
            1. 求数组项之和
            2. 求数组项最大值
            3. 数组去重
            
            进阶用法可以进行数组的转化，对象属性的累加（Object.keys()返回属性的数组）
            
    26.构造函数继承问题
        class Dog {
          constructor(name) {
            this.name = name;
          }
        };
        
        class Labrador extends Dog {
          // 1 
          constructor(name, size) {
            this.size = size;
          }
          // 2
          constructor(name, size) {
            super(name);
            this.size = size;
          }
          // 3
          constructor(size) {
            super(name);
            this.size = size;
          }
          // 4 
          constructor(name, size) {
            this.name = name;
            this.size = size;
          }
        
        }
        
        只有2才正确继承
        
        在子类中，在调用super之前不能访问到this关键字。
        使用super关键字，需要用给定的参数来调用父类的构造函数。 父类的构造函数接收name参数，因此我们需要将name传递给super。
        
    27.import引入时
        // index.js
        console.log('running index.js');
        import { sum } from './sum.js';
        console.log(sum(1, 2));
        
        // sum.js
        console.log('running sum.js');
        export const sum = (a, b) => a + b;
        
        import命令是编译阶段执行的，在代码运行之前。因此这意味着被导入的模块会先运行，而导入模块的文件会后执行。
        这是CommonJS中require（）和import之间的区别。使用require()，您可以在运行代码时根据需要加载依赖项。 
        如果我们使用require而不是import，running index.js，running sum.js，3会被依次打印。
        
    28.Symbol
        每个Symbol都是完全唯一的。传递给Symbol的参数只是给Symbol的一个描述。
        Symbol的值不依赖于传递的参数。
        
        28.1  应用场景1
                Symbol可同样用于对象属性的定义和访问：
                    const PROP_NAME = Symbol()
                    const PROP_AGE = Symbol()
                    
                    let obj = {
                       [Symbol('name')]: '一斤代码',
                       age: 18,
                       title: 'Engineer'
                    }
                    
                    Symbol类型的key是不能通过Object.keys()或者for...in来枚举的，
                    它未被包含在对象自身的属性名集合(property names)之中。
                    
                    JSON.stringify()将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外：
                    JSON.stringify(obj)  // {"age":18,"title":"Engineer"}
                    
                有专门的api来获取symbol属性
                    // 使用Object的API
                    Object.getOwnPropertySymbols(obj) // [Symbol(name)]
                    
                    // 使用新增的反射API
                    Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']
            
        28.2 应用场景2：使用Symbol来替代常量
            const TYPE_AUDIO = Symbol()
            const TYPE_VIDEO = Symbol()
            const TYPE_IMAGE = Symbol()
            
            function handleFileResource(resource) {
              switch(resource.type) {
                case TYPE_AUDIO:
                  playAudio(resource)
                  break
                case TYPE_VIDEO:
                  playVideo(resource)
                  break
                case TYPE_IMAGE:
                  previewImage(resource)
                  break
                default:
                  throw new Error('Unknown type of resource')
              }
            }
        
        
        28.3 注册和获取全局Symbol    
            Symbol.for()，它可以注册或获取一个window间全局的Symbol实例：
                let gs1 = Symbol.for('global_symbol_1')  //注册一个全局Symbol
                let gs2 = Symbol.for('global_symbol_1')  //获取全局Symbol
                
                gs1 === gs2  // true
            
            就算在iframe里也同样适用    
            这样一个Symbol不光在单个window中是唯一的，在多个相关window间也是唯一的了。
    
    29.ES6-字符串扩展  padStart()，padEnd()
        padStart() 用于头部补全；
        padEnd() 用于尾部补全。
        
        'x'.padStart(5, 'ab') // 'ababx' 参数一为长度，参数二为补齐的字符串
        'xxx'.padStart(2, 'ab') // 'xxx' 源字符串大于指定长度，则返回源字符串
         
        'x'.padEnd(5, 'ab') // 'xabab'
        'x'.padEnd(4, 'ab') // 'xaba'
        
        '12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
        '09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
        
    30.generator
        写法{value: x, done: true/false}
        
        function* aaa(){
            yield 'dsfsf'
        }
        
        yield相当于暂停操作,每次都会返回右边语句的返回值，
        以{value: x, done: true/false}形式返回，done为false表示
        还没执行完，为true才是执行完毕
        而generator都需要执行next()执行下一步
        aaa().next() ==> {value: xxx, done:false}
        
        
        function* next_id() {
            var current_id = 0;
            while(current_id < 100){
               current_id++;
               yield current_id;
               console.log(current_id)
            }
        }
        
        var
        x,
        pass = true,
        g = next_id();
        for (x = 1; x < 100; x ++) {
            if (g.next().value !== x) {
                pass = false;
                console.log('测试失败!');
                break;
            }
        }
        if (pass) {
            console.log('测试通过!');
        }
        
        这里是返回了从0到99的方法
        
    31.String.raw
        String.raw() 是一个模板字符串的标签函数,
        用来获取一个模板字符串的原始字符串的
        
        String.raw(callSite, ...substitutions)
        String.raw`templateString`
        
        callSite
            一个模板字符串的“调用点对象”。类似{ raw: ['foo', 'bar', 'baz'] }。
        ...substitutions
            任意个可选的参数，表示任意个内插表达式对应的值。
        templateString
            模板字符串，可包含占位符（${...}）。
            
        String.raw`Hi\n${2+3}!`;
        // 'Hi\n5!'，Hi 后面的字符不是换行符，\ 和 n 是两个不同的字符,任何转义都失效
        
        let name = "Bob";
        String.raw `Hi\n${name}!`;             
        // "Hi\nBob!"
        
        String.raw({ raw: 'test' }, 0, 1, 2); // 't0e1s2t'
        String.raw({
          raw: ['foo', 'bar', 'baz'] 
        }, 2 + 3, 'Java' + 'Script'); // 'foo5barJavaScriptbaz'
        
    32.in
        如果指定的属性在指定的对象或其原型链中，则in 运算符返回true。
        
        "PI" in Math          // 返回true
        
        
#### 45.多页面应用配置
    在vue-cli的基础下
    
    新增build/setting.js
        const fs = require('fs');
        const path = require('path');
        //使用node.js 的文件操作模块来获取src文件夹下的文件夹名称 ->[about,common,home]
        const entryFiles = fs.readdirSync(path.resolve(__dirname, '../src/pages'));
        //生成html文件插件
        const HtmlWebpackPlugin = require('html-webpack-plugin');
        const { _resolve } = require('./utils');
        //入口文件过滤common文件夹(因为common文件夹我们用来存放多页面之间公用的方法与css,所以不放入入口进行构建!)
        const rFiles = entryFiles.filter(v => v != 'common');
        module.exports = {
          //构建webpack入口
          entryList: () => {
            const entryList = {};
            rFiles.map(v => {
              entryList[v] = _resolve(`../src/pages/${v}/index.js`);
            });
            return entryList;
          },
          //src文件夹下的文件夹名称 ->[about,common,home]
          entryFiles: entryFiles,
          //使用html-webpack-plugin生成多个html页面.=>[home.html,about.html]
          // vue-cli脚手架自带的HtmlWebpackPlugin要删掉，对应根目录的index.html也要删掉
          pageList: () => {
            const pageList = [];
            rFiles.map(v => {
              pageList.push(
                new HtmlWebpackPlugin({
                  template: _resolve(`../src/pages/${v}/index.html`),
                  filename: _resolve(`../dist/${v}.html`),
                  chunks: ['common', 'manifest', 'vendor', v], //注意点
                  //压缩配置
                  minify: {
                    //删除Html注释
                    removeComments: true,
                    //去除空格
                    collapseWhitespace: true,
                    //去除属性引号
                    removeAttributeQuotes: true
                  },
                  chunksSortMode: 'dependency'
                })
              );
            });
            return pageList;
          }
        };
        
        注意：上面的注意点，生产环境的 webpack.optimize.CommonsChunkPlugin 要按顺序排列，manifest要排在vendor前面
        
    新建style.js  这个文件给生成环境使用的，用于分离css文件
        //抽取css文件插件
        const ExtractTextPlugin = require('extract-text-webpack-plugin');
        //引入入口配置
        const { entryFiles } = require('./setting.js');
        //多个ExtractTextPlugin实例
        const plugins = [];
        entryFiles.map(v => {
          plugins.push(
            new ExtractTextPlugin({
              filename: `css/${v}.[contenthash].css`,
              allChunks: false
            })
          );
        });
        
        const rules = [];
        entryFiles.map((v, k) => {
          rules.push({
            test: new RegExp(`src(\\\\|\/)${v}(\\\\|\/)style(\\\\|\/).*\.(css|less)$`),
            use: plugins[k].extract({
              fallback: 'style-loader',
              use: ['css-loader', 'postcss-loader', 'less-loader']
            })
          });
        });
        
        module.exports = {
          //使用正则匹配到每个页面对应style文件夹下的css/less文件,并配置loader来进行解析.从而实现html<->css 1对1
          rulesList: rules,
          //插件实例
          stylePlugins: plugins
        };
    
    webpack.base.conf.js
    
        const { entryList, pageList } = require('./setting.js');
        
        entry: entryList(),
        
        plugins:[...pageList()]
        
    webpack.prod.conf.js
        const { rulesList, stylePlugins } = require('./style.js');
        
        module: {
            rules: [
              utils.styleLoaders({
                sourceMap: config.build.productionSourceMap,
                extract: true,
                usePostCSS: true
              }),
              ...rulesList()
          ]
          
         plugins:[
            ...
            ...stylePlugins
         ] 
        } 
        
#### 46.exports和module.exports和export和export default import和require的区别
      在es5中，用module.exports和exports导出模块，用require引入模块。（不是绝对，如果代码支持es6，也可以用import引入）
      es6新增export和export default导出模块，import导入模块。  
      
    1. module.exports和exports一开始都是一个空对象{}，这两个对象指向同一块内存。
      这也就是说module.exports和exports是等价的
      
      当两者不一样，被修改后，require引入的是module.exports
      module.exports = {a:1}
      exports = {b:1}
      
      require(xxx) => {a:1}
    
    2.export和export default
      通过export方式导出，在导入时要加{ }，export default则不需要
      在一个文件或模块中，export、import可以有多个，export default仅有一个
      输出单个值，使用export default，输出多个值，使用export
      
    3.import的文件会自动执行一次。
      import会加载且仅加载一次导入的模块  
      
      require是运行时执行
      
#### 47.file-loader和url-loader的区别
    以图片为例，file-loader可对图片进行压缩，但是还是通过文件路径进行引入，
    当http请求增多时会降低页面性能，而url-loader通过设定limit参数，小于limit字
    节的图片会被转成base64的文件，大于limit字节的将进行图片压缩的操作。
    图片较大，编码会消耗性能。因此url-loader提供了一个limit参数，小于limit字节的
    文件会被转为DataURl，大于limit的还会使用file-loader进行copy。
    总而言之，url-loader是file-loader的封装，内置了file-loader。
#### 48.vue-cli2部分配置详解
    config/index.js
        'use strict'
        const path = require('path')
        
        module.exports = {
          dev: {
            // 开发环境下面的配置
            assetsSubDirectory: 'static',//子目录，一般存放css,js,image等文件
            assetsPublicPath: '/',//根目录
            proxyTable: {},//可利用该属性解决跨域的问题
            host: 'localhost', // 地址
            port: 8080, //端口号设置，端口号占用出现问题可在此处修改
            autoOpenBrowser: false,//是否在编译（输入命令行npm run dev）后打开http://localhost:8080/页面，以前配置为true，近些版本改为false，个人偏向习惯自动打开页面
            errorOverlay: true,//浏览器错误提示
            notifyOnErrors: true,//跨平台错误提示
            poll: false, //使用文件系统(file system)获取文件改动的通知devServer.watchOptions
            devtool: 'cheap-module-eval-source-map',//增加调试，该属性为原始源代码（仅限行）不可在生产环境中使用
            cacheBusting: true,//使缓存失效
            cssSourceMap: true//代码压缩后进行调bug定位将非常困难，于是引入sourcemap记录压缩前后的位置信息记录，当产生错误时直接定位到未压缩前的位置，将大大的方便我们调试
          },
        
          build: {
          // 生产环境下面的配置
            index: path.resolve(__dirname, '../dist/index.html'),//index编译后生成的位置和名字，根据需要改变后缀，比如index.php
            assetsRoot: path.resolve(__dirname, '../dist'),//编译后存放生成环境代码的位置
            assetsSubDirectory: 'static',//js,css,images存放文件夹名
            assetsPublicPath: './',//发布的根目录，通常本地打包dist后打开文件会报错，此处修改为./。如果是上线的文件，可根据文件存放位置进行更改路径
            productionSourceMap: true, //打包后，由于代码都是压缩的，代码报错无法得知哪里的问题，开启后生成map文件，可以用来debug
            devtool: '#source-map',//此选项控制是否生成，以及如何生成 source map
            //unit的gzip命令用来压缩文件，gzip模式下需要压缩的文件的扩展名有js和css
            productionGzip: false,
            productionGzipExtensions: ['js', 'css'],
            bundleAnalyzerReport: process.env.npm_config_report
          }
          //sourcemap是为了解决开发代码与实际运行代码不一致时帮助我们debug到原始开发代码的技术
        }
        
    build/build.js
        'use strict'
        require('./check-versions')()//check-versions：调用检查版本的文件。加（）代表直接调用该函数
        process.env.NODE_ENV = 'production'//设置当前是生产环境
        //下面定义常量引入插件
        const ora = require('ora')//①加载动画
        const rm = require('rimraf')//②删除文件
        const path = require('path')
        const chalk = require('chalk')//③对文案输出的一个彩色设置
        const webpack = require('webpack')
        const config = require('../config')//默认读取下面的index.js文件
        const webpackConfig = require('./webpack.prod.conf')
        //调用start的方法实现加载动画，优化用户体验
        const spinner = ora('building for production...')
        spinner.start()
        //先删除dist文件再生成新文件，因为有时候会使用hash来命名，删除整个文件可避免冗余
        rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err => {
          if (err) throw err
          webpack(webpackConfig, (err, stats) => {
            spinner.stop()
            if (err) throw err
            process.stdout.write(stats.toString({ //打印
              colors: true,
              modules: false,
              children: false, // If you are using ts-loader, setting this to true will make TypeScript errors show up during build.
              chunks: false,
              chunkModules: false
            }) + '\n\n')
        
            if (stats.hasErrors()) {
              process.exit(1)
            }
        
            console.log(chalk.cyan('  Build complete.\n'))
            console.log(chalk.yellow(
              '  Tip: built files are meant to be served over an HTTP server.\n' +
              '  Opening index.html over file:// won\'t work.\n'
            ))
          })
        })
        
    build/utils.js 用于处理css
        'use strict'
        const path = require('path')
        const config = require('../config')
        const ExtractTextPlugin = require('extract-text-webpack-plugin') //用于抽离css文件
        const packageConfig = require('../package.json')
        //导出文件的位置，根据环境判断开发环境和生产环境，为config文件中index.js文件中定义的build.assetsSubDirectory或dev.assetsSubDirectory
        exports.assetsPath = function (_path) {
          const assetsSubDirectory = process.env.NODE_ENV === 'production'
            ? config.build.assetsSubDirectory
            : config.dev.assetsSubDirectory
        //Node.js path 模块提供了一些用于处理文件路径的小工具①
          return path.posix.join(assetsSubDirectory, _path) 
          
          //path.posix：提供对路径方法的POSIX（可移植性操作系统接口）特定实现的访问，
          //即可跨平台，区别于win32。
          //path.join：用于连接路径，会正确使用当前系统的路径分隔符，Unix系统是"/"，Windows系统是""
        }
        
        exports.cssLoaders = function (options) {
          options = options || {}
        //使用了css-loader和postcssLoader，通过options.usePostCSS属性来判断是否使用postcssLoader中压缩等方法
          const cssLoader = {
            loader: 'css-loader',
            options: {
              sourceMap: options.sourceMap
            }
          }
        
          const postcssLoader = {
            loader: 'postcss-loader',
            options: {
              sourceMap: options.sourceMap
            }
          }
          function generateLoaders (loader, loaderOptions) {
            const loaders = options.usePostCSS ? [cssLoader, postcssLoader] : [cssLoader]
            if (loader) {
              loaders.push({
                loader: loader + '-loader',
                //Object.assign是es6语法的浅复制，后两者合并后复制完成赋值
                options: Object.assign({}, loaderOptions, {
                  sourceMap: options.sourceMap
                })
              })
            }
            
            if (options.extract) {
            //ExtractTextPlugin可提取出文本，代表首先使用上面处理的loaders，当未能正确引入时使用vue-style-loader
              return ExtractTextPlugin.extract({
                use: loaders,
                fallback: 'vue-style-loader'
              })
            } else {
            //返回vue-style-loader连接loaders的最终值
              return ['vue-style-loader'].concat(loaders)
            }
          }
          return {
            css: generateLoaders(),//需要css-loader 和 vue-style-loader
            postcss: generateLoaders(),//需要css-loader和postcssLoader  和 vue-style-loader
            less: generateLoaders('less'),//需要less-loader 和 vue-style-loader
            sass: generateLoaders('sass', { indentedSyntax: true }),//需要sass-loader 和 vue-style-loader
            scss: generateLoaders('sass'),//需要sass-loader 和 vue-style-loader
            stylus: generateLoaders('stylus'),//需要stylus-loader 和 vue-style-loader
            styl: generateLoaders('stylus')//需要stylus-loader 和 vue-style-loader
          }
        }
        exports.styleLoaders = function (options) {
          const output = []
          const loaders = exports.cssLoaders(options)
            //将各种css,less,sass等综合在一起得出结果输出output
          for (const extension in loaders) {
            const loader = loaders[extension]
            output.push({
              test: new RegExp('\\.' + extension + '$'),
              use: loader
            })
          }
        
          return output
        }
        
        exports.createNotifierCallback = () => {
        //发送跨平台通知系统
          const notifier = require('node-notifier')
        
          return (severity, errors) => {
            if (severity !== 'error') return
        //当报错时输出错误信息的标题，错误信息详情，副标题以及图标
            const error = errors[0]
            const filename = error.file && error.file.split('!').pop()
        
            notifier.notify({
              title: packageConfig.name,
              message: severity + ': ' + error.name,
              subtitle: filename || '',
              icon: path.join(__dirname, 'logo.png')
            })
          }
        }
        
    webpack.base.conf.js
        'use strict'
        const path = require('path')
        const utils = require('./utils')
        const config = require('../config')
        const vueLoaderConfig = require('./vue-loader.conf')
        
        function resolve (dir) {
        //拼接出绝对路径
          return path.join(__dirname, '..', dir)
        }
        module.exports = {
        //path.join将路径片段进行拼接，而path.resolve将以/开始的路径片段作为根目录，在此之前的路径将会被丢弃
        //path.join('/a', '/b') // 'a/b',path.resolve('/a', '/b') // '/b'
          context: path.resolve(__dirname, '../'),
          //配置入口，默认为单页面所以只有app一个入口
          entry: {
            app: './src/main.js'
          },
          //配置出口，默认是/dist作为目标文件夹的路径
          output: {
            path: config.build.assetsRoot,//路径
            filename: '[name].js',//文件名
            publicPath: process.env.NODE_ENV === 'production'
              ? config.build.assetsPublicPath
              : config.dev.assetsPublicPath//公共存放路径
          },
          resolve: {
          //自动的扩展后缀，比如一个js文件，则引用时书写可不要写.js
            extensions: ['.js', '.vue', '.json'],
            //创建路径的别名，比如增加'components': resolve('src/components')等
            alias: {
              'vue$': 'vue/dist/vue.esm.js',
              '@': resolve('src'),
            }
          },
          //使用插件配置相应文件的处理方法
          module: {
            rules: [
            //使用vue-loader将vue文件转化成js的模块①
              {
                test: /\.vue$/,
                loader: 'vue-loader',
                options: vueLoaderConfig
              },
              //js文件需要通过babel-loader进行编译成es5文件以及压缩等操作②
              {
                test: /\.js$/,
                loader: 'babel-loader',
                include: [resolve('src'), resolve('test'), resolve('node_modules/webpack-dev-server/client')]
              },
              //图片、音像、字体都使用url-loader进行处理，超过10000会编译成base64③
              {
                test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                loader: 'url-loader',
                options: {
                  limit: 10000,
                  name: utils.assetsPath('img/[name].[hash:7].[ext]')
                }
              },
              {
                test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
                loader: 'url-loader',
                options: {
                  limit: 10000,
                  name: utils.assetsPath('media/[name].[hash:7].[ext]')
                }
              },
              {
                test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
                loader: 'url-loader',
                options: {
                  limit: 10000,
                  name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
                }
              }
            ]
          },
          //以下选项是Node.js全局变量或模块，这里主要是防止webpack注入一些Node.js的东西到vue中 
          node: {
            setImmediate: false,
            dgram: 'empty',
            fs: 'empty',
            net: 'empty',
            tls: 'empty',
            child_process: 'empty'
          }
        }
        
    webpack.dev.conf.js
        'use strict'
        const utils = require('./utils')
        const webpack = require('webpack')
        const config = require('../config')
        //通过webpack-merge实现webpack.dev.conf.js对webpack.base.config.js的继承
        const merge = require('webpack-merge')
        const path = require('path')
        const baseWebpackConfig = require('./webpack.base.conf')
        const CopyWebpackPlugin = require('copy-webpack-plugin')
        const HtmlWebpackPlugin = require('html-webpack-plugin')
        
        //美化webpack的错误信息和日志的插件①
        const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')
        const portfinder = require('portfinder')// 查看空闲端口位置，默认情况下搜索8000这个端口②
        const HOST = process.env.HOST//③processs为node的一个全局对象获取当前程序的环境变量，即host
        const PORT = process.env.PORT && Number(process.env.PORT)
        
        const devWebpackConfig = merge(baseWebpackConfig, {
          module: {
          //规则是工具utils中处理出来的styleLoaders，生成了css，less,postcss等规则
            rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
          },
        
          devtool: config.dev.devtool,  //增强调试，上文有提及
          //此处的配置都是在config的index.js中设定好了
          devServer: {//④
            clientLogLevel: 'warning',//控制台显示的选项有none, error, warning 或者 info
            //当使用 HTML5 History API 时，任意的 404 响应都可能需要被替代为 index.html
            historyApiFallback: true
            hot: true,//热加载
            contentBase: false,
            compress: true,//压缩
            host: HOST || config.dev.host,
            port: PORT || config.dev.port,
            open: config.dev.autoOpenBrowser,//调试时自动打开浏览器
            overlay: config.dev.errorOverlay
              ? { warnings: false, errors: true }
              : false,// warning 和 error 都要显示
            publicPath: config.dev.assetsPublicPath,
            proxy: config.dev.proxyTable,//接口代理
            quiet: true, //控制台是否禁止打印警告和错误,这也意味着来自的WebPack的错误或警告在控制台不可见。若用FriendlyErrorsPlugin 此处为 true
            watchOptions: {
              poll: config.dev.poll,//// 文件系统检测改动
            }
          },
          plugins: [
            new webpack.DefinePlugin({
              'process.env': require('../config/dev.env')
            }),
            new webpack.HotModuleReplacementPlugin(),//⑤模块热替换插件，修改模块时不需要刷新页面
            new webpack.NamedModulesPlugin(), // 显示文件的正确名字
            new webpack.NoEmitOnErrorsPlugin(),//当webpack编译错误的时候，来中端打包进程，防止错误代码打包到文件中
            // https://github.com/ampedandwired/html-webpack-plugin
            // 该插件可自动生成一个 html5 文件或使用模板文件将编译好的代码注入进去⑥
            new HtmlWebpackPlugin({
              filename: 'index.html',
              template: 'index.html',
              inject: true  //表示静态资源注入模板，将js引入放在body尾部，其css脚本放在头部
            }),
            new CopyWebpackPlugin([//复制插件
              {
                from: path.resolve(__dirname, '../static'),
                to: config.dev.assetsSubDirectory,
                ignore: ['.*']//忽略.*的文件
              }
            ])
          ]
        })
        
        module.exports = new Promise((resolve, reject) => {
          portfinder.basePort = process.env.PORT || config.dev.port
          //查找端口号
          portfinder.getPort((err, port) => {
            if (err) {
              reject(err)
            } else {
            //端口被占用时就重新设置evn和devServer的端口
              process.env.PORT = port
              devWebpackConfig.devServer.port = port
              //友好地输出信息
              devWebpackConfig.plugins.push(new FriendlyErrorsPlugin({
                compilationSuccessInfo: {
                  messages: [`Your application is running here: http://${devWebpackConfig.devServer.host}:${port}`],
                },
                onErrors: config.dev.notifyOnErrors
                ? utils.createNotifierCallback()
                : undefined
              }))
              resolve(devWebpackConfig)
            }
          })
        })
        
    webpack.prod.conf.js
        'use strict'
        const path = require('path')
        const utils = require('./utils')
        const webpack = require('webpack')
        const config = require('../config')
        const merge = require('webpack-merge')
        const baseWebpackConfig = require('./webpack.base.conf')
        const CopyWebpackPlugin = require('copy-webpack-plugin')
        const HtmlWebpackPlugin = require('html-webpack-plugin') // 文件名即使更改，自动打包并且生成响应的文件在index.html里面
        const ExtractTextPlugin = require('extract-text-webpack-plugin') // 它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件
        const OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin') //用于优化或者压缩CSS资源
        const UglifyJsPlugin = require('uglifyjs-webpack-plugin') //压缩js文件
        
        const env = require('../config/prod.env')
        
        const webpackConfig = merge(baseWebpackConfig, {
          module: {
          //调用utils.styleLoaders的方法
            rules: utils.styleLoaders({
              sourceMap: config.build.productionSourceMap,//开启调试的模式。默认为true
              extract: true,
              usePostCSS: true
            })
          },
          devtool: config.build.productionSourceMap ? config.build.devtool : false,
          output: {
            path: config.build.assetsRoot,
            filename: utils.assetsPath('js/[name].[chunkhash].js'),
            chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')
          },
          plugins: [
            new webpack.DefinePlugin({
              'process.env': env
            }),
            new UglifyJsPlugin({
              uglifyOptions: {
                compress: {//压缩
                  warnings: false//警告：true保留警告，false不保留
                }
              },
              sourceMap: config.build.productionSourceMap,
              parallel: true //启用并行化
            }),
            // 它会将所有的入口 chunk(entry chunks)中引用的 *.css，移动到独立分离的 CSS 文件
            new ExtractTextPlugin({//抽取文本。比如打包之后的index页面有style插入，就是这个插件抽取出来的，减少请求
              filename: utils.assetsPath('css/[name].[contenthash].css'),  
              allChunks: true,
            }),
            
            new OptimizeCSSPlugin({//优化css的插件
              cssProcessorOptions: config.build.productionSourceMap
                ? { safe: true, map: { inline: false } }
                : { safe: true }
            }),
           
            new HtmlWebpackPlugin({//html打包
              filename: config.build.index,
              template: 'index.html',
              inject: true,
              minify: {//压缩
                removeComments: true,//删除index.html中的注释
                collapseWhitespace: true,//删除index.html中的空格
                removeAttributeQuotes: true//删除各种html标签属性值的双引号   
              },
             
              chunksSortMode: 'dependency'//模块排序，按照我们需要的顺序排序
            }),
           
            new webpack.HashedModuleIdsPlugin(),//该插件会根据模块的相对路径生成一个四位数的hash作为模块id, 建议用于生产环境。
            
            // 预编译所有模块到一个闭包中，提升你的代码在浏览器中的执行速度。
            new webpack.optimize.ModuleConcatenationPlugin(),//启用作用域提升，作用是让代码文件更小、运行的更快
            
            // 将所有从node_modules中引入的js提取到vendor.js，即抽取库文件
            new webpack.optimize.CommonsChunkPlugin({//抽取公共的模块
              name: 'vendor',
              minChunks (module) {   
                return (
                  module.resource &&
                  /\.js$/.test(module.resource) &&
                  module.resource.indexOf(
                    path.join(__dirname, '../node_modules')
                  ) === 0
                )
              }
            }),
            new webpack.optimize.CommonsChunkPlugin({
              name: 'manifest',
              minChunks: Infinity
            }),
            new webpack.optimize.CommonsChunkPlugin({
              name: 'app',
              async: 'vendor-async',
              children: true,
              minChunks: 3
            }),
            new CopyWebpackPlugin([//复制，比如打包完之后需要把打包的文件复制到dist里面
              {
                from: path.resolve(__dirname, '../static'),
                to: config.build.assetsSubDirectory,
                ignore: ['.*']
              }
            ])
          ]
        })
        
        if (config.build.productionGzip) {
          const CompressionWebpackPlugin = require('compression-webpack-plugin')
        
          webpackConfig.plugins.push(
            new CompressionWebpackPlugin({
              asset: '[path].gz[query]',
              algorithm: 'gzip',
              test: new RegExp(
                '\\.(' +
                config.build.productionGzipExtensions.join('|') +
                ')$'
              ),
              threshold: 10240,
              minRatio: 0.8
            })
          )
        }
        
        if (config.build.bundleAnalyzerReport) {
          const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
          webpackConfig.plugins.push(new BundleAnalyzerPlugin())
        }
        
        module.exports = webpackConfig

#### 49.Webpack中publicPath详解
    output选项指定webpack输出的位置，其中比较重要的也是经常用到的有path和publicPath
    
    output.path
        默认值：process.cwd() //总是返回运行 node 命令时所在的文件夹的绝对路径
        output.path只是指示输出的目录，对应一个绝对路径，例如在项目中通常会做如下配置：
        output: {
        	path: path.resolve(__dirname, '../dist'),
        }
    
    output.publicPath
        默认值：空字符串
        该配置能帮助你为项目中的所有资源指定一个基础路径，它被称为公共路径(publicPath)。
        这里说的所有资源的基础路径是指项目中引用css，js，img等资源时候的一个基础路径，这个
        基础路径要配合具体资源中指定的路径使用，所以其实打包后资源的访问路径可以用如下
        
        公式表示：
            静态资源最终访问路径 = output.publicPath + 资源loader或插件等配置路径
            
        output.publicPath = '/dist/'
        // image
        options: {
         	name: 'img/[name].[ext]?[hash]'
        }
        // 最终图片的访问路径为
        output.publicPath + 'img/[name].[ext]?[hash]' = '/dist/img/[name].[ext]?[hash]'
    
    webpack-dev-server中的publicPath
        一般情况下都要保证devServer中的publicPath与output.publicPath保持一致
        
    斜杠/的含义
        配置中/代表url根路径，例如http://localhost:8080/dist/js/test.js中的http://localhost:8080/    
        
#### 50.ExtractTextPlugin中的fallback的含义
        ExtractTextPlugin.extract({
          use: "css-loader",
          fallback: "style-loader"
        })
        
        use指需要什么样的loader去编译文件
        fallback:编译后用什么loader来提取css文件
        
        
#### 51、 js原型、原型链？有什么特点
        原型：
            Javascript规定，每一个函数都有一个prototype对象属性，指向另一个对象（原型链上面的）。
            prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。
            prototype可以让所有对象实例共享它所包含的属性和方法。
            
            只有函数才有prototype属性，但普通对象（实例对象）有_proto_属性
            
            普通对象都是通过new Object创建的实例
        
        原型链：
            实例对象与原型之间的连接，叫做原型链。
            实例对象通过_proto_找到构造函数的原型prototype
            
        对象访问一个属性或方法时，会先查找对象自身，没有的话会去找其原型上的属性或方法。
        每个对象都有一个proto属性,原型链上的对象正是依靠这个属性连结在一起
        
        一般原型用于添加共用属性和方法
        
        构造器constructor
            function Person() {
               
            }
            var p = new Person()
            console.log(Person.prototype); // Object{} 
            console.log(p.prototype); // undifined
            console.log(p.constructor); //function Person(){}    
            此处的p是通过 Person函数构造出来的，所以p的constructor属性指向Person
            console.log(Person.constructor); //function Function(){}
            之前提过，每个函数其实是通过new Function（）构造的
            console.log({}.constructor); // function Object(){}
            每个对象都是通过new Object（）构造的
            console.log(Object.constructor); // function Function() {}
            Object也是一个函数，它是Function（）构造的
            console.log([].constructor);  //function Array(){}
            
            console.log(Function instanceof Object); // true
            console.log(Object instanceof Function); // true
            
        object instanceof constructor
            instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。
            
            // 定义构造函数
            function C(){} 
            function D(){} 
            
            var o = new C();
            
            o instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype
            
            o instanceof D; // false，因为 D.prototype 不在 o 的原型链上
            
            o instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true
            C.prototype instanceof Object // true，同上
            
            C.prototype = {};
            var o2 = new C();
            
            o2 instanceof C; // true
            
            o instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.
            
            D.prototype = new C(); // 继承
            var o3 = new D();
            o3 instanceof D; // true
            o3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上
            
        特点：原型链实现了继承
        
        原型链:
          什么是: 由多级父对象逐级继承，形成的链式结构，通过__proto__实现子类共用原型链上的属性和方法，向上查找
        
        原型链的运行机制：
            1. 所有的函数数据类型都天生自带一个属性：prototype（原型），这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存
            2. 在浏览器给prototype开辟的堆内存中有一个天生自带的属性：constructor，这个属性存储的值是当前函数本身
            3. 每一个对象都有一个__proto__的属性，这个属性指向当前实例所属类的prototype（如果不能确定它是谁的实例，都是Object的实例）
            
        Function的原型指向Object的原型，Object的原型的原型最终指向null    
        
#### 52、 什么是事件循环event loop
        JS的代码执行是基于一种事件循环的机制，所以称作事件循环
        JS是单线程执行的，而基于事件循环模型，形成了基本没有阻塞（除了alert或同步XHR等操作）的状态
        
        根据 规范，每个线程都有一个事件循环（Event Loop），在浏览器中除了主要的页面执行线程 外，
        Web worker是在一个新的线程中运行的，所以可以将其独立看待。
        
        每个事件循环有至少一个任务队列（TaskQueue，也可以称作Macrotask宏任务），各个任务队列中放置
        着不同来源（或者不同分类）的任务，可以让浏览器根据自己的实现来进行优先级排序以及一个微任务
        队列（Microtask Queue），主要用于处理一些状态的改变，UI渲染工作之前的一些必要操作（可以防
        止多次无意义的UI渲染）主线程的代码执行时，会将执行程序置入执行栈（Stack）中，执行完毕后出栈，
        另外有个堆空间（Heap），主要用于存储对象及一些非结构化的数据
        
        1 、所有同步任务都在主线程上执行，形成一个执行栈
    　　2、主线程之外，还存在一个"消息队列"。只要异步操作执行完成，就到消息队列中排队
    　　3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异
    　　步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行
        4、主线程不断重复上面的第三步
        
        由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环
        
        注：消息队列又称事件队列、任务队列，分为两类，宏任务（script全部代码、setTimeout、
        setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、
        I/O、UI Rendering）
        MicroTask（微任务）：Process.nextTick（Node独有）、Promise、Object.observe(废弃)、
        MutationObserver
        
        在挂起任务时，JS 引擎会将所有任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一
        个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至
        两个队列的任务都取完。

        
#### 53、 import和require有什么区别
        
        import 
            1.在编译时，它必须放在文件开头，目前部分浏览器不支持，需要用babel把es6转成es5再执行
            2.import是解构过程，只加载import的方法，其他不加载，性能比require要好
            （es6模块不是对象，而是通过export命令指定输出代码，再通过import输入，只加载import中导的方法，其他方法不加载）
            3.目前浏览器不支持，本质上是通过babel转换为require来兼容
            4.es6的一个语法标准
            5.模块输出的是值的引用，动态关联模块中的值
            
        require 
            1.在运行时，可以随处引入
            2.require是赋值过程，将整个模块运行后，生成一个对象赋值给某个变量
            3.CommonJs的语法
            4.输出的是值的拷贝，值的改变不回影响引用方
            
        import()动态加载，比如import a from '路径'，这里的路径必须是给定的字符串
        不能使用变量来动态控制，因为import是编译时运行的，动态控制需要运行时进行
        所以引入import()
            1.动态的 import() 提供一个基于 Promise 的 API
            2.动态的import() 可以在脚本的任何地方使用
            3.import() 接受字符串文字，你可以根据你的需要构造说明符
            
            import().then(...)

        
#### 54、 有哪些模块化框架
    主流模块化框架
        commonJS
        AMD(Asynchronous Module Definition)
        CMD(Common Module Definition)
        UMD(Universal Module Definition)
        ES6规范
        
        commonJS模块化
            定义模块：即一个单独的文件就是一个模块，切该文件中的作用域独立，当中的变量是无法被其他文件
            引用的，如果要使用需要将其定义为global；
            输出模块：模块只有一个出口，即使用module.exports对象，将需要输出的内容放入到该对象中；
            加载模块：通过require加载，例如：var module = require('./moduleFile.js');该module的值即对
            应文件内部的module.exports对象， 然后就可以通过module名称去引用模块中的变量和函数了；
            
            commonJS是基于服务器端开发的，由于require是同步加载，所以当在浏览器中是无法运行的，所以就
            有了下面的异步模块的出现。
        
        AMD(Asynchronous Module Definition)，异步模块定义
            AMD是一套基于浏览器端模块化开发的规范, 是 RequireJS 在推广过程中对模块定义的规范化产出。
            
            requireJS是一个AMD框架，可以异步加载JS文件，通过define()函数定义，第一个参数是一个数组，
            里面定义一些需要依赖的包，第二个参数是一个回调函数，回调函数的参数是相应依赖返回值，最后
            通过return来输出。
            requireJS也可以就近依赖，通过require引入，官方推荐按照amd规范使用
            requireJS是一个依赖前置、异步定义的AMD框架，在定义的同时如果需要用到别
            的模块，在最前面定义好即在参数数组里面进行引入，在回调里面加载
            define()
            requireJS解决了两个问题
            多文件依赖关系处理，被依赖的需要早一步被加载；
            加载js时候页面会停止渲染，如果加载的文件越多，页面失去响应的时间就会越长；
            
            // AMD 默认推荐的是
                define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
                     a.doSomething()
                    // 此处略去 100 行
                    b.doSomething()
                    ...
                })
            
            requireJS常用指令require，define
                其中define是用于定义模块，而require是用于载入模块以及载入配置文件。
                
                <script src="js/require.js"></script>
                <script>
                    //require配置
                    require.config({
                        baseUrl:'js/',
                        paths:{ //这里配置的依赖，在后面引入的依赖可以直接用名称引入，无需使用路径
                            'jquery':'http://xxxx.xxx.com/js/jquery.min',
                            'index':'index'
                        }
                    });

                    require(['index']);
                </script>
                
                可以定义全局变量require来自动配置
                <script>
                    var require = {
                        baseUrl: 'js/',
                        paths: {
                            'jquery': 'http://xxx.xxxx.com/js/jquery.min',
                            'index': 'index'
                        },
                        deps:[index]
                    };
                </script>
                <script src="js/require.js"></script>
                
                也可以使用入口文件
                <script src="js/require.js"></script>
                <script src="js/app.js"></script>
                
                或者
                <script data-main="js/app" src="js/require.js"></script>
                
                define([id,deps,] callback) 
                    id为模块名，默认的便是文件名，一般无需使用者自己手动指定
                    deps：为依赖包，数组形式
                    
                    非依赖模块只有callback
                    define(function(require,exports,modules){
                        // do something
                        return {
                        'color':'red',
                        'size':'13px'
                        }
                    });
                    也可以通过exports导出
                    
                    define(['jquery','require','exports','modules'], function($,require,exports,modules) {
                        $(function() {
                            //方式一
                            require(['utils'],function(utils){
                                utils.sayHellow('Hellow World!');
                            });
                            //方式二：
                            var utils = require('utils');
                            utils.sayHellow('hellow World')
                        });
                    });
                    
                
            
        CMD(Common Module Definition)通用模块定义
            CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。
            就近依赖，需要时再进行加载，所以执行顺序和书写顺序一致；这点与AMD不同，AMD是在使用模块之前将
            依赖模块全部加载完成，但由于网络等其他因素可能导致依赖模块下载先后顺序不一致这就导致了，执行
            顺序可能跟书写顺序不一致的情况。
            
            SeaJS是淘宝团队提供的一个模块开发的js框架.通过define()定义，CMD是依赖就近，哪里需
            要用就require引入依赖，即用即返，这是一个同 步的概念
            
            // CMD
                define(function(require, exports, module) {
                    var a = require('./a')
                    a.doSomething()
                    // 此处略去 100 行
                    var b = require('./b') // 依赖可以就近书写
                    b.doSomething()
                    // ...
                })
            
            seaJS跟requireJS相似
                seajs.config({  
                    // 只定base目录，类似java中的src目录  
                    base: './javascripts/',  
                    // 目录长的可以声明别名, 这点十分人性化  
                    alias: {  
                    },  
                    // 下面配置自己理解  
                    charset: 'utf-8',  
                    timeout: 20000,  
                    debug: 0  
                });  
                  
                  
                define(function(require, exports, module) {  
                    // 如果没有配置base, 需要用 require('./javascripts/increment')  
                    var inc = require('increment').increment;  
                      
                    var a = 1;  
                    console.log(inc(a));  
                })  
                
                <script src="lib/sea-debug.js" type="text/javascript" charset="utf-8" data-main="./javascripts/main"></script>  
        区别：
            1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。
            不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）
            2. CMD 推崇依赖就近，AMD 推崇依赖前置。
            3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。
            比如 AMD 里，require 分全局 require 和局部 require，都叫 require。
            CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现
            模块系统的加载启动。CMD 里，每个 API 都简单纯粹。
            
        UMD(Universal Module Definition)
            希望提供一个前后端跨平台的解决方案(支持AMD与CommonJS模块方式),。
            先判断是否支持Node.js模块格式（exports是否存在），存在则使用Node.js模块格式。
            再判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。
            前两个都不存在，则将模块公开到全局（window或global）。
        
        ES6模块化，未来标准，但目前未广泛使用
            优点
                类似commonJS，语法更简洁；
                类似AMD，直接支持异步加载和配置模块加载；
                结构可以做静态分析，静态检测；
                比commonJS更好的支持循环依赖；
                语法概述
                
                命名式导出方式：每个模块可以有多个
                定义式导出方式：每个模块只有一个
        
        
#### 55、 MVC和MVVM
    MV不是一种技术 ，而是一种设计理念。MV*模式主要采用分层的思想来降低耦合度，
    从而使系统更加灵活，扩展性更强。它通过关注数据界面分离，来鼓励改进应用程序结构。
    
    Model（模型）：数据层，负责保存应用数据，数据的管理。Model不涉及表示层，而是代表应用程序
                   可能需要的独特形式的数据。当Model改变时，它会通知它的观察者(如视图)
                   作出相应的反应。
    View（视图）： 视图层，Model 的可视化表示，表示当前状态的视图。前端View负责构建和维护DOM元素。
    
    不同点在于：
    Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户
                          输入，并向模型发送数据。
    VM（视图模型）：通过数据绑定，自动完成M、V之间的更新
    
    一、早期的mvc
        以前的前端只需要写样式，把模板给后端填入数据，前端只完成了view层部分
        
        缺点
            1前端页面开发效率不高
            2前后端职责不清晰
    
    二、前端mvc
        与后端类似，具有view,controller,model，mvc模式是单项绑定，即model绑定到view，当我们用js代码更新model时，view就会自动更新
        
            model负责数据保存，与后端数据进行同步
            controller负责业务逻辑，根据用户行为对model数据进行修改
            view负责视图展示，将model中的数据可视化出来
            
            用户触发事件，v层发送指令到c层，c层通知m层变化数据，m层将变化后的数据展现在v层
        
        缺点：1.m层和v层能互相通信，两层之间存在耦合
              2.一个小小的功能都必须经过这么一个流程，并不灵活
    
    三、前端mvvm
        vm代替controller，vm作为view和model的中间层，把v层和m层分离，通过一套自动响应的机制，
        自动响应model数据变化，响应到view层，减少大量的dom操作和复杂代码
        
        MVVM框架与MVC框架的主要区别有两点：
            1、实现数据与视图的分离
            2、通过数据来驱动视图，开发者只需要关心数据变化，DOM操作被封装了。
            
#### 56.从输入url地址到页面展示，浏览器做了什么
    1. 在浏览器地址栏输⼊URL 
    2. 浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤 
        1. 如果资源未缓存，发起新请求 
        2. 如果已缓存，检验是否⾜够新鲜，⾜够新鲜直接提供给客户端，否则与服务器进⾏验 证。 
        3. 检验新鲜通常有两个HTTP头进⾏控制 Expires 和 Cache-Control ： HTTP1.0提供Expires，值为⼀个绝对时间表示缓存新鲜⽇期 HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最⼤新鲜时间
    3. 浏览器解析URL获取协议，主机，端⼝，path 
    4. 浏览器组装⼀个HTTP（GET）请求报⽂ 
    5. 浏览器获取主机ip地址，过程如下：
        1. 浏览器缓存 
        2. 本机缓存 
        3. hosts⽂件 
        4. 路由器缓存 
        5. ISP DNS缓存 
        6. DNS递归查询（可能存在负载均衡导致每次IP不⼀样）
    6. 打开⼀个socket与⽬标IP地址，端⼝建⽴TCP链接，三次握⼿如下：
        1. 客户端发送⼀个TCP的SYN=1，Seq=X的包到服务器端⼝ 
        2. 服务器发回SYN=1， ACK=X+1， Seq=Y的响应包 
        3. 客户端发送ACK=Y+1， Seq=Z 
    7. TCP链接建⽴后发送HTTP请求 
    8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使⽤HTTP Host头部判断请 求的服务程序 
    9. 服务器检查HTTP请求头是否包含缓存验证信息如果验证缓存新鲜，返回304等对应状态码 
    10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作 
    11. 服务器将响应报⽂通过TCP连接发送回浏览器 
    12. 浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重⽤，关闭TCP连接的四 次握⼿如下： 
        1. 主动⽅发送Fin=1， Ack=Z， Seq= X报⽂ 
        2. 被动⽅发送ACK=X+1， Seq=Z报⽂ 
        3. 被动⽅发送Fin=1， ACK=X， Seq=Y报⽂ 
        4. 主动⽅发送ACK=Y， Seq=X报⽂ 
    13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同 
    14. 如果资源可缓存，进⾏缓存 
    15. 对响应进⾏解码（例如gzip压缩） 
    16. 根据资源类型决定如何处理（假设资源为HTML⽂档） 
    17. 解析HTML⽂档，构件DOM树，下载资源，构造CSSOM树，执⾏js脚本，这些操作没有严 格的先后顺序，以下分别解释 
    18. 构建DOM树： 
        1. Tokenizing：根据HTML规范将字符流解析为标记 
        2. Lexing：词法分析将标记转换为对象并定义属性和规则 
        3. DOM construction：根据HTML标记关系将对象组成DOM树 
    19. 解析过程中遇到图⽚、样式表、js⽂件，启动下载 
    20. 构建CSSOM树： 
        1. Tokenizing：字符流转换为标记流
        2. Node：根据标记创建节点 
        3. CSSOM：节点创建CSSOM树 
    21. 根据DOM树和CSSOM树构建渲染树 : 
        1. 从DOM树的根节点遍历所有可⻅节点，不可⻅节点包括：
            1） script , meta 这样本身 不可⻅的标签。
            2)被css隐藏的节点，如 display: none
        2. 对每⼀个可⻅节点，找到恰当的CSSOM规则并应⽤ 
        3. 发布可视节点的内容和计算样式 
    22. js解析如下： 
        1. 浏览器创建Document对象并解析HTML，将解析到的元素和
           ⽂本节点添加到⽂档中，此 时document.readystate为loading 
        2. HTML解析器遇到没有async和defer的script时，将他们添加
           到⽂档中，然后执⾏⾏内 或外部脚本。这些脚本会同步执⾏，
           并且在脚本下载和执⾏时解析器会暂停。这样就可以⽤document.write()
           把⽂本插⼊到输⼊流中。同步脚本经常简单定义函数和注册事
           件处理程序，他们可以遍历和操作script和他们之前的⽂档内容 
        3. 当解析器遇到设置了async属性的script时，开始下载脚本
           并继续解析⽂档。脚本会在它 下载完成后尽快执⾏，但是解析
           器不会停下来等它下载。异步脚本禁⽌使⽤ document.write()，
           它们可以访问⾃⼰script和之前的⽂档元素
        4. 当⽂档完成解析，document.readState变成interactive 
        5. 所有defer脚本会按照在⽂档出现的顺序执⾏，延迟脚本能
           访问完整⽂档树，禁⽌使⽤ document.write() 
        6. 浏览器在Document对象上触发DOMContentLoaded事件
        7. 此时⽂档完全解析完成，浏览器可能还在等待如图⽚等内容加载，
           等这些内容完成载⼊ 并且所有异步脚本完成载⼊和执⾏，document.readState变为complete，
           window触发 load事件
    23. 显示⻚⾯（HTML解析过程中会逐步显示⻚⾯）
    
#### 57.HTTP状态码及其含义
    1XX ：信息状态码
        100 Continue 继续，⼀般在发送 post 请求时，已发送了 http header 之后服务端 将返回此信息，表示确认，之后发送具体参数信息
    2XX ：成功状态码
        200 OK 正常返回信息
        201 Created 请求成功并且服务器创建了新的资源
        202 Accepted 服务器已接受请求，但尚未处理
    3XX ：重定向
        301 Moved Permanently 请求的⽹⻚已永久移动到新位置。
        302 Found 临时性重定向。
        303 See Other 临时性重定向，且总是使⽤ GET 请求新的 URI 。
        304 Not Modified ⾃从上次请求后，请求的⽹⻚未修改过。
    4XX ：客户端错误
        400 Bad Request 服务器⽆法理解请求的格式，客户端不应当尝试再次使⽤相同的内 容发起请求。
        401 Unauthorized 请求未授权。
        403 Forbidden 禁⽌访问。
        404 Not Found 找不到如何与 URI 相匹配的资源。
    5XX: 服务器错误
        500 Internal Server Error 最常⻅的服务器端错误。
        503 Service Unavailable 服务器端暂时⽆法处理请求（可能是过载或维护）。
    
#### 58.四大浏览器内核介绍
    (1)Trident内核  ie
    
    (2)Gecko内核 火狐
    
    (3)WebKit内核 谷歌和safari
    
    (4)Blink内核 Opera
    
#### 59.iframe的缺点
    1.阻塞主页面的资源加载和解析
    2.无法被搜索引擎检索，不利于seo
    
    要使用iframe最好js动态添加，这样可以避免以上问题
    
#### 60.WEB标准以及W3C标准是什么? 
    标签闭合、标签⼩写、不乱嵌套、使⽤外链 css 和 js 、结构⾏为表现的分离

#### 61.xhtml和html有什么区别?
    ⼀个是功能上的差别 兼容性强，各种客户端都可以正确解析
    另外是书写习惯的差别，XHTML 元素必须被正确地嵌套，闭合，区分⼤⼩写，⽂档必须拥有根元素
    
#### 62.Doctype作⽤
    <!DOCTYPE> 声明位于⽂档中的最前⾯，处于 <html> 标签之前。告知浏览器
    的解析器， ⽤什么⽂档类型 规范来解析这个⽂档
    
#### 63.svg和canvas的区别
    svg 绘制出来的每⼀个图形的元素都是独⽴的 DOM 节点，能够⽅便的绑定事件或⽤来修改。 
    canvas 输出的是⼀整幅画布
    
    svg 输出的图形是⽮量图形，后期可以修改参数来⾃由放⼤缩⼩，不会失真和锯⻮。⽽
    canvas 输出标量画布，就像⼀张图⽚⼀样，放⼤会失真或者锯⻮

#### 64.viewport
    <meta name="viewport" content="width=device-width,initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0,user-scalable=no "></meta>

#### 65.移动端1px问题
    1.为什么会有1px问题
        社保像素比（DPR): 设备像素比 = 设备像素/设备独立像素。
        
        css像素（虚拟像素 ）：就是代码写的像素值
        设备像素（物理像素）：指设备能显示的最小物理单位。
        设备独立像素（逻辑像素）：也是指虚拟像素
        
        所以css上为1px，在dpr为2的设备上将会显示为2px
        
    2.解决方案
        伪类+transfrom:scale(0.5)
        全部边框
            .border:after{
                content:'';
                position:absolute;
                box-sizing:border-box;
                top:0;
                left:0;
                width:200%;
                height:200%;
                transform:scale(0.5);
                border:1px solid;
            }
        
        单边框
            .border:before{
                content:'';
                position:absolute;
                top:0;
                left:0;
                border-top:1px solid;
                transform:scale(.5);
            }
            
        追求更仔细的，使用媒体查询，区分像素比
        @media(-webkit-min-device-pixel-ratio:2.75){
            .border:before{
                ...
                width:275%;
                height:275%;
                -webkit-transform:scale(1/2.75)
            }
        }
        
    同理0.5px的边框怎么实现
        也是通过将1px缩小一半实现

#### 66.渐进增强和优雅降级
    渐进增强是在保证在低版本浏览器的基本功能完全的情况下，对高版本浏览器增加功能和效果
    优雅降级是一开始构建完整的功能，然后针对低版本浏览器进行兼容。
    
#### 68.webP和Apng
    webP:体积比jpeg小40%，加载速度快
    Apng:png的位图动画扩展，动图，有望代替gif
    
#### 69.行内元素间隙解决办法
    1.移除空格
    2.font-size：0；
    3.margin负值
    4.letter-spacing
    5.word-spacing

#### 70.jpeg、gif、png
    jpeg：有损压缩，可控制压缩质量、不支持透明、适合照片
    PNG：文件小，支持透明度，适合图标背景、按钮
    gif：无损压缩，适合简单动画
    
#### 71.::before和:after的单冒号和双冒号的区别
    单冒号用于css3伪类，双冒号用于css3伪元素
    
#### 72.如果需要手动写动画，时间间隔多少合适
    多数显示器默认频率为60hz，1秒刷新60次，所以间隔为
    1/60 *1000ms = 16.7ms
    
#### 73.base64的原理和优缺点
    优点：可以加密，减少请求
    缺点：需要消耗cpu进行编解码
    
#### 74.重绘和回流（重排）
    修改了元素的⼏何属性,影响页面布局，浏览器需要重新构造渲染树，这个过程称为重排；
    浏览器将受到影响的部分，重新绘制到屏幕上的过程称为重绘。
    
    引起重排的原因有
        添加或者删除可⻅的DOM元素；
        元素位置、尺⼨、内容改变；
        浏览器⻚⾯初始化；
        浏览器窗⼝尺⼨改变，重排⼀定重绘，重绘不⼀定重排，
    
    减少重绘和重排的⽅法： 
        不在布局信息改变时做 DOM 查询 
        使⽤ cssText 或者 className ⼀次性改变属性 
        使⽤ fragment
        对于多次重排的元素，如动画，使⽤绝对定位脱离⽂档流，让他的改变不影响到其他元素
        
#### 75.offsetWidth/offsetHeight,clientWidth/clientHeight与 scrollWidth/scrollHeight的区别
        offsetWidth/offsetHeight 返回值包含content + padding + border，效果与 e.getBoundingClientRect()相同
        clientWidth/clientHeight 返回值只包含content + padding，如果有滚动条，也不包 含滚动条
        scrollWidth/scrollHeight 返回值包含content + padding + 溢出内容的尺⼨
        
#### 76.jq源码那些地方写的好
    1.jq源码封装在一个匿名函数的自执行环境中，可以避免变量污染问题，
      将window对象传入作为局部变量，可以避免作用域链过长，同理也传入
      了undefined
    2.经常用到的变量，将其作为局部变量使用，提高访问速度
    
#### 77.node的应用场景
    特点：
        1.js环境
        2.依赖于chrome v8引擎
        3.事件驱动
        4.非阻塞I/o
        5.单进程，单线程
        
    优点：
        高并发性能优越
    缺点：
        1、只支持单核cpu，不能充分利用cpu
        2、可靠性低，一旦代码某个环节崩溃，整个系统崩溃
        
#### 78.null和undefined的区别
    undefined表示不存在这个值
    null表示一个对象定义为空值
    
#### 79.面向对象和面向过程编程
    面向过程是分析出解决问题所需要的步骤，函数一步步实现
    面向对象是把构成问题的事务分解成各个对象，描述某个事物在整个解决过程的行为
    
    面向对象是以功能划分，面向过程是以步骤划分
    
    面向对象容易维护和扩展，开发效率高
    
#### 80.let和var
    let不存在变量提升
    let不允许重复声明
    
#### 81.箭头函数和普通函数的区别
    1.箭头函数的this的指向，是在定义时所在的对象，不是调用时所在的对象
    2.不可以当作构造函数，不可以使用new命令
    3.不可以使用arguments对象，可以用Rest参数代替，形式为...变量名，（...a）=>{typeof a} //array
    4.不可以使用yield命令，不能用作generator函数
    
#### 82.数组和对象的遍历方式
    1.for in 遍历数组，性能比较差
    2.for 性能也比较差，循环每进行一次，就要检查一下数组长度。
    3.forEach 无法遍历对象，ie不支持，无法使用continue和break，使用return跳过本次循环
    4.map
    
#### 83.gulp是什么
    基于流的代码构建器，是自动化项目的构建利器。
    能对网站资源优化，使用工具完成重复的工作
    gulp的特点：易于使用，构建快速，易于学习
    
#### 84.快速让一个数组乱序
    var arr = [xxx,xxx,xxx]
    arr.sort(function(){
        return Math.random()-0.5
    })
    
#### 85.window.onload和$(document).ready
    window.onload()方法是必须等到页面内包括图片的所有元素加载完毕后才能执行
    $().ready是dom结构绘制完毕后就执行，不必等到加载完毕
    
#### 86.addEventListener和attachEvent的区别
    1.add是w3c规范的标准方法，attachEvent是ie低版本的非标准方法
    2.add支持冒泡和捕获事件，att只支持冒泡
    3.add参数的事件类型不需要添加‘on'，att需要
    4.add同元素事件按顺序执行，att按倒序执行
    
#### 87.数组去重
    1.es6 set
     Array.from(new Set(arr))
     
    2.for循环嵌套
        for
         for(var j = i + 1.....)
            if
                arr.splice(j,1)
                
    3.sort
        arr.sort()排序，比较相邻元素
    
    4.利用对象，通过属性不能相同的特点去重
        !obj[arr[i]] obj[arr[i]] = 1
        
        再通过object.keys(obj) 导出可枚举属性的数组
        
#### 88.怎么判断两个对象相等
    obj = {a:1,b:1} obj2 = {a:1,b:1}
    JSON.stringify(obj) === JSON.stringify(obj2)
    
#### 89.缓存验证
    浏览器缓存分为强制缓存和协商缓存
    
    强制缓存
        在第一次请求后，获取了响应头部的缓存信息和规则，下一次请求时，
        会查询缓存规则和失效日期，若没有失效，则直接从磁盘缓存取
        判断规则为expires（有效时间，http1.0的东西，现在多数都为http1.1，么得）和cache-control(缓存模式和失效时间)
        
        cache-control常见取值为 
            private 客户端可缓存
            public 客户端和代理服务器可缓存
            max-age=xxx 多少秒后失效
            no-cache 需要使用协商缓存来验证
            no-store 不缓存
        
    协商缓存
        无论是否过期，先发送请求给服务器，校验一下缓存规则和失效日期，
        如果缓存没失效，返回一个缓存标志304，允许使用缓存，则从缓存中取
        
        判断规则
            一种是判断时间
                第一次请求回来响应头会带有last-Modified字段，表示资源最后修改时间
                客户端将其存储起来，第二次请求会在请求头带上If-Modified-Since（就是上次请求
                回来的修改时间）跟服务器做对比，没失效则返回304
                
            一种是判断标识
                第一次请求响应头返回ETag的资源唯一标识，同样存储起来，
                第二次请求在If-None-Match带上该标识跟服务器对比，不一样
                标识资源修改过，则重新拉取
                
            标识优先级高于失效时间
        
    强制缓存优先级比协商缓存高
    
#### 90.webpack打包优化思路
    1.提取第三方库或者外部引入
    2.代码压缩
    3.生产环境取消source-map的生成
    4.剥离css文件，单独打包
    5.去除不必要插件，生产环境配置和开发环境配置要分开
    6.使用一下可优化的插件
        构建优化
            减少编译体积contextReplacementPugin、babel-plugin-import，
            uglifyjsWebpackPlugin开启并行和缓存，
            预编译dllWebpackPlugin
        性能优化
            Tree-shaking减少编译体积
            拆包splitChunksPlugin
            
#### 91.判断是否为数组
    1.instanceof
        var b = {};
        b instanceof Array
    2.constructor
        var a = [];
        a.constructor === Array
    3.object.prototype.toString.call()
        Object.prototype.toString.call(obj) === '[object Array]'
    4.Array.isArray()
    
#### 92.排序
    1.冒泡排序
        比较相邻两个数，后小的就换位
        var arr = [3,4,1,6,5,7,2]
        
        function bubbleSort(arr){
            for(var i = 0;i < arr.length - 1;i++){
                for(var j = 0;j < arr.length - i -1;j++){
                    if(arr[j] > arr[j+1]){
                        var temp = arr[j];
                        arr[j] = arr[j+1]
                        arr[j+1] = temp
                    }
                }
            }
        }
        
    2.快速排序
        二分法，取出中间数，数组每次和中间数比较，小放左，大放右，递归调用
        var arr = [3,1,2,5,6,7]
        
        function quickSort(arr){
            if(arr.length == 0){
                return []
            }
            
            var cIndex = Math.floor(arr.length/2)
            var c = arr.splice(cIndex,1)
            var l = [], r = []
            
            for(var i = 0;i < arr.length;i++){
                if(arr[i] < c){
                    l.push(arr[i])
                }else{
                    r.push(arr[i])
                }
            }
            
            return quickSort(l).concat(c, quickSort(r))
        }
        
        console.log(quickSort(arr))
        
        
#### 93.输出今天日期
    yyyy-mm-dd
    var d = new Date()
    var year = d.getFullYear()
    var month = d.getMonth() + 1
    month = month < 10?'0' + month: month
    var day = d.getDate();
    day = day < 10?'0' + day : day;
    year + '-' ...............
    
    
#### 94.去除字符串前后空格，考虑兼容性
    if(!String.prototype.trim){
        String.prototype.trim = function(){
            return this.replace(/^\s+/,"").replace(/\s+$/,"")
        }
    }
    "  sdsdsd".trim()

#### 95.判断是否为回文字符串
    function run(input){
        if(typeof input === 'string') return false;
        return input.split('').reverse().join('') === input
    }

#### 96.arguments不是单纯的数组
    数组的方法arguments无法使用
    [...arguments] Array.from(arguments)

#### 97.正则表达式
    "^" :^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。
    "$" ：$会匹配行或字符串的结尾
    "\b" :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如从
            字符串中"This is Regex"匹配单独的单词 "is" 正则就要写成 "\bis\b"
            \b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界
    "\d": 匹配数字，
　　     如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$
    "\w"：匹配字母，数字，下划线.
    　　  匹配"a2345BCD__TTz" 正则："\w+"  这里的"+"字符为一个量词指重复的次数。
    "\s"：匹配空格 
    　　  例如字符 "a b c" 正则："\w\s\w\s\w"  一个字符后跟一个空格，如有字符间有多个空格直接把"\s" 写成 "\s+" 让空格重复
    "."： 匹配除了换行符以外的任何字符
    　　  这个算是"\w"的加强版， 匹配字符"a23 4 5 B C D__TTz"  正则：".+"
    "[abc]": 字符组  匹配包含括号内元素的字符 
            这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，
    
    反义
    "\W"   匹配任意不是字母，数字，下划线 的字符
    "\S"   匹配任意不是空白符的字符
    "\D"  匹配任意非数字的字符
    "\B"  匹配不是单词开头或结束的位置
    "[^abc]"  匹配除了abc以外的任意字符
    
    量词
    "*"(贪婪)   重复零次或更多
　　　  例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a*"   会出到所有的字符"a"
     "+"(懒惰)   重复一次或更多次
　　     例如"aaaaaaaa" 匹配字符串中所有的a  正则： "a+"  会取到字符中所有的a字符，  "a+"与"a*"不同在于"+"至少是一次而"*" 可以是0次，
　　     稍后会与"?"字符结合来体现这种区别
     "?"(占有)   重复零次或一次
　　     例如"aaaaaaaa" 匹配字符串中的a 正则 ： "a?" 只会匹配一次，也就是结果只是单个字符a
　  "{n}"  重复n次
　　     例如从"aaaaaaaa" 匹配字符串的a 并重复3次 正则：  "a{3}"  结果就是取到3个a字符  "aaa";
　  "{n,m}"  重复n到m次
    "{n,}"  重复n次或更多次
 　　    与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则"a{3,}" a至少要重复3次
 　　    
#### 98.怎么判断页面加载完成
    Load 事件触发代表⻚⾯中的 DOM ， CSS ， JS ，图⽚已经全部加载完毕。
    DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析（Dom解析完毕），不需要等待
    CSS ， JS ，图⽚加载
    
#### 99.typeof null为object，是一个长久的bug
    typeof对于基本类型数据除了null以外都正确
    
#### 100.proxy
    proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截
    
    var proxy = new Proxy(target, handler);
    target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为
    
    var target = {
       name: 'poetries'
     }
     
     var logHandler = {
       get: function(target, key) {
         return target[key];
       },
       set: function(target, key, value) {
         target[key] = value;
       }
     }
     
     var targetWithLog = new Proxy(target, logHandler);
     
     targetWithLog.name; // 控制台输出：poetries
     targetWithLog.name = 'others'; // name 被设置为 others
     
     console.log(target.name); // 控制台输出: others
     
#### 101.图层
    图层之间渲染互不影响，频繁渲染的部分建议使用独立图层，提高性能
    但是过多图层也会适得其反
    
    使用以下属性可以创建图层
        3D 变换： translate3d 、 translateZ
        will-change
        video 、 iframe 标签
        通过动画实现的 opacity 动画转换
        position: fixed

#### 102.减少重绘和回流 
    1.使⽤ translate 替代 top
    2.使⽤ visibility 替换 display: none 前者引起重绘，后者引发回流
    3.不要使⽤ table 布局，可能很⼩的⼀个⼩改动会造成整个 table 的重新布局
    4.动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使⽤requestAnimationFrame
    5.CSS 选择符从右往左匹配查找，避免 DOM 深度过深 
    6.将频繁运⾏的动画变为图层，图层能够阻⽌该节点回流影响别的元素。
    
#### 103.小程序架构
    微信⼩程序的框架包含两部分 View 视图层、 App Service 逻辑层。
    View 层⽤来渲染⻚⾯结构， AppService 层⽤来逻辑处理、数据请求、接 ⼝调⽤。 它们在两个线程⾥运⾏。 视图层和逻辑层通过系统层的 JSBridage 进⾏通信，逻辑层把数据变化通知 到视图层，触发视图层⻚⾯更新，视图层把触发的事件通知到逻辑层进⾏业务处理
    
    小程序渲染机制
        每个page对应一个webview，多个webview共享一个js运行环境
        1.视图层使⽤ WebView 渲染， iOS 中使⽤⾃带 WKWebView ，在 Android 使⽤腾讯的
        x5 内核（基于 Blink ）运⾏。
        2.逻辑层使⽤在 iOS 中使⽤⾃带的 JSCore 运⾏，在 Android 中使⽤腾讯的 x5 内核 （基于 Blink ）运⾏。 3.开发⼯具使⽤ nw.js 同时提供了视图层和逻辑层的运⾏环境。
        
#### 104.小程序的问题
    1.⼩程序仍然使⽤ WebView 渲染，并⾮原⽣渲染。（部分原⽣） 服务端接⼝返回的头⽆法执⾏，⽐如： Set-Cookie 。
    2.不⽀持使⽤⾃⼰的字体。
    3.⼩程序不能发朋友圈（可以通过保存图⽚到本地，发图⽚到朋友前。⼆维码可以使⽤B接 ⼝）。 
    4.转发（分享）⼩程序不能拿到成功结果，原来可以。
    5. ⼩程序授权需要⽤户主动点击
    6.⼩程序不提供测试 access_token
    
#### 105.小程序性能优化
    代码包的⼤⼩是最直接影响⼩程序加载启动速度的因素。代码包越⼤不仅下载 速度时间⻓，业务代码注⼊时间也会变⻓。所以最好的优化⽅式就是减少代码包的⼤⼩
    
    优化⽅式 
        1.代码压缩。
        2.及时清理⽆⽤代码和资源⽂件。 
        3.减少代码包中的图⽚等资源⽂件的⼤⼩和数量。
        4.分包加载，分包还可以预下载，进入分包页面的延迟就能够尽可能降低
          部分独立性很强，不是很复杂的场景（活动页），推荐使用独立分包
          独立分包跟其他分包不同，不依赖于主包的下载
        5.避免阻塞渲染
            在小程序启动流程中，会顺序执行app.onLaunch, app.onShow, page.onLoad, page.onShow,
            page.onReady，所以，尽量避免在这些生命周期中使用Sync结尾的同步API，如
            wx.setStorageSync，wx.getSystemInfoSync 等。
        
    ⾸屏加载的体验优化建议 
        1.提前请求: 异步数据请求不需要等待⻚⾯渲染完成。 
        2.利⽤缓存: 利⽤ storage API 对异步请求数据进⾏缓存，⼆次启动时先利⽤缓存数据渲 
        染⻚⾯，在进⾏后台更新。 3.避免⽩屏：先展示⻚⾯⻣架⻚和基础内容。 
        4.及时反馈：即时地对需要⽤户等待的交互操作给出反馈，避免⽤户以为⼩程序⽆响应
        
    渲染性能优化
        1.避免不当使用setData, setData一次数据量不应太大，不应频繁使用
          每次setData的数据应仅是渲染相关的数据，setData不应在后台使用
          应该在前台页面展示时使用
        2.避免不当使用onPageScroll,在onPageScroll避免频繁执行setData、处理
          复杂逻辑、频繁查询节点信息
        3.使用自定义组件，组件更新只在内部进行，不会影响其他内容
        
#### 106.react
    1.概述下 React 中的事件处理逻辑
        为了解决跨浏览器兼容性问题， React 会将浏览器原⽣事件（ Browser
        Native Event ）封装为合成事件（ SyntheticEvent ）传⼊设置的事件处理 器中。
        这⾥的合成事件提供了与原⽣事件相同的接⼝，不过它们屏蔽了底层浏 览器的细节差异，
        保证了⾏为的⼀致性。另外有意思的是， React 并没有直 接将事件附着到⼦元素上，
        ⽽是以单⼀事件监听器的⽅式将所有的事件发送到顶层进⾏处理。这样 React 在更
        新 DOM 的时候就不需要考虑如何去处理附着在 DOM 上的事件监听器，最终达到优化性能的⽬的
        
    2.react组件的划分业务组件技术组件？ 
        根据组件的职责通常把组件分为UI组件和容器组件。 UI 组件负责 UI 的
        呈现，容器组件负责管理数据和逻辑。 
        
    3.react⽣命周期函数 
        初始化阶段
            getDefaultProps :获取实例的默认属性
            getInitialState :获取每个实例的初始化状态
            componentWillMount ：组件即将被装载、渲染到⻚⾯上
            render :组件在这⾥⽣成虚拟的 DOM 节点
            componentDidMount :组件真正在被装载之后 
        运⾏中状态
            componentWillReceiveProps :组件将要接收到属性的时候调⽤
            shouldComponentUpdate :组件接受到新属性或者新状态的时候（可以返回false，接收数
            据后不更新，阻⽌ render 调⽤，后⾯的函数不会被继续执⾏了）
            componentWillUpdate :组件即将更新不能修改属性和状态
            render :组件重新描绘
            componentDidUpdate :组件已经更新 
        销毁阶段
            componentWillUnmount :组件即将销毁
            
    4.为什么虚拟dom会提⾼性能 
        虚拟 dom 相当于在 js 和真实 dom 中间加了⼀个缓存，
        利⽤ dom diff 算 法避免了没有必要的 dom 操作，从⽽提⾼性能
        
    5.react的坑点
        5.1. JSX做表达式判断时候，需要强转为boolean类型 
              如果不使⽤ !!b 进⾏强转数据类型，会在⻚⾯⾥⾯输出 0 。 
        5.2. 尽量不要在 componentWillReviceProps ⾥使⽤ setState，如果⼀定要使⽤，那么需要判
        断结束条件，不然会出现⽆限重渲染，导致⻚⾯崩溃  
        5.3. 给组件添加ref时候，尽量不要使⽤匿名函数，因为当组件更新的时候，匿名函数会被当做
        新的prop处理，让ref属性接受到新函数的时候，react内部会先清空ref，也就是会以null为回
        调参数先执⾏⼀次ref这个props，然后在以该组件的实例执⾏⼀次ref，所以⽤匿名函数做ref
        的时候，有的时候去ref赋值后的属性会取到null 
        5.4. 遍历⼦节点的时候，不要⽤ index 作为组件的 key 进⾏传⼊
        
    6. react 的渲染过程中，兄弟节点之间是怎么处理的？也就是key值 不⼀样的时候 
        key就是给每⼀个 reactNode 添加⼀个身份标识，在重渲染 
        过程中，如果key⼀样，若组件属性有所变化，则 react 只更新组件对应的属 
        性；没有变化则不更新，如果key不⼀样，则react先销毁该组件，然后重新创 
        建该组件
        
    7.说说react
        mvvm为react的特性之⼀，虽然react属于单项数据流，需要我们⼿动实现双向数据绑定，
        react封装了修改Dom的操作。react同时还使用了虚拟dom，通过diff算法的比较，比较出
        需要更新的dom节点，避免了全量更新dom的引起性能低下的问题。
        redux的做法比较规范，但是小功能依然需要写复杂的代码，适合大型项目
        mobx的写法代码简约，比较随意，内部也做好了是否重渲染组件的⽣命周期shouldUpdateComponent，
        适合小型项目

#### 107.vue
    1.vue的路由实现hash模式和history模式
        hash模式：路由后面添加了符号#,用window.location.hash读取#后面的字符。
                  hash不会重加载页面，对服务端安全无用
        history模式: history采用h5新特性，使用了history的pushState()和replaceState()，对
        历史记录栈进行修改，以及popState事件的监听状态的变更
        
    2.$route和$router
        $route是路由信息对象，包含了path，params，hash，query等路由信息参数
        $router是路由实例，包含了跳转方法，钩子函数等
        
    3.nextTick
        nextTick可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获取更新好的DOM
    
    4.vue的优点
        4.1 低耦合性。解绑了view层和model，限定只通过vm层来通信
        4.2 可重用性。可以把视图逻辑放在vm层里，让其他view来重用
        4.3 可测试性。界面素来是比较难于测试，而现在测试可以针对vm来写
        
    5.实现vue ssr
        5.1 基本原理
            1.app.js作为两端的公用入口，导出vue根实例，供客户端entry与服务端entry使用，
              客户端entry主要作用挂载到DOM上，服务端entry除了创建和返回实例，还进行路
              由匹配和数据预获取
            2.webpack为客户端打包一个client Bundle,服务端 server Bundle
            3.服务器接收到请求时，根据url加载相应组件，获取并解析异步数据，创建一个读取
              server Bundle的BundleRenderer，然后生成html发送给客户端
            4.客户端收到从服务端传来的Dom与自己生成的DOM进行对比，把不相同的DOM激活，使
              其可以能够响应后续变化，这个过程称为客户端激活。为确保混合成功，客户端与
              服务端需要共享一套数据。在服务端可以渲染之前获取的数据，填充到store里，
              在客户端挂载到DOM之前，可以直接从store里取数据。首屏的动态数据通过
              window._INITIAL_STATE_发送到客户端
              
    6.vue组件data为什么必须是函数
        每个组件都是vue的实例，组件共享data属性，data为函数时，每次都会返回一个独立
        的data，修改data时不会 影响其他组件
        
    7. vue complier实现，模板解析
       vue complier就是将template转化成一个render字符串
       
       有以下步骤：
        parse过程，将template利用正则转化成AST抽象语法树。
        optimize过程，标记静态节点，然后diff过程跳过静态节点，提升性能
        generate过程，生成render字符串
        
#### 108.脏数据检测
    angular通过脏数据检测实现数据双向绑定
    触发指定事件会进入脏数据检测，这时调用$digest遍历所有数据观察者，有差异
    则调用$watch函数，然后再调用$digest循环检测，直到发现没有变化。循环至少
    为两次，至多十次。
    
    脏数据检测虽然存在低效问题，但是不关心数据通过什么方式改变。
    脏数据可以实现批量检测出需要更新的值，然后再同一更新UI，大大减少了DOM
    操作次数。所以低效是相对的。

#### 109.为什么tcp需要第三次握手
    当请求超时，tcp会重新发起请求，这是服务器响应，顺利建立连接。然后第一次请求
    在第二连接关闭后到达服务器，如果只需要两次握手，这时服务器会开启连接等待
    客户端传数据，而这是客户端早已关闭，这样会白白浪费服务器资源，所以
    第三次握手防止失效请求被服务器接收，从而产生错误
    
#### 110.post和get的区别
    1.get请求能缓存，post不能缓存，比如浏览器能后退
    2.post比较安全，get请求包含在url中，且可以被浏览器保存历史记录，post不会，
    但是在抓包的情况下都一样（Fiddler）
    3.post可通过请求body来传输，get不能，可传输的数据量比get大
    4.url长度对get有影响，浏览器会限制长度
    5.post支持更多的编码类型，且不对数据类型限制
    6.get请求多用于无副作用，幂等的场景，比如搜索；post多用于副作用，不幂等的场景，比如注册
    
#### 111.DNS
    DNS的作用就是通过域名查找具体的IP,
    域名相当于IP的别名，域名方便查看和记忆
    DNS查询是操作系统做的
    
#### 112.数据结构
    1.栈
        一个线性结构，遵循先进后出的原则
    2.队列
        一个线性结构，遵循先进先出的原则
    3.链表
        一个线性结构，同时也是一个递归结构。
        数据元素的逻辑顺序是通过链表中的指
        针链接次序实现的
        
        大致分为单链表和双向链表
            1.单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针
            2.双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针
            
            链表的优点在于,不需要连续的存储单元,修改链表的复杂度为O(1) (在不考虑查找时)
            但是缺点也很明显:无法直接找到指定节点,只能从头节点一步一步寻找复杂度为O(n)
    4.树
        树也是一个递归结构
        
        二叉树
            拥有一个根节点，每个节点最多拥有两个子节点，分别为左节点和右节点，
            最底部节点为叶节点，当一颗树的叶数量为满的时候，叫满二叉树
            
        二分搜索树
            拥有二叉树的特性，其节点的值比左子树大，比右子树小，这种存储
            方式很适合数据搜索。
    5.堆
        堆通常是一个可看作一棵树的数组对象
        堆的实现通过构造二叉堆，实为二叉树的一种。
        任意节点小于或大于它的所有子节点，堆是一颗完整的树。
        将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆
        叫做最小堆或小根堆
        
#### 113.时间复杂度
    通常使用最差的时间复杂度来衡量一个算法的好坏。
    简单的说，算法中一个反复执行次数最多的语句来表示其算法的时间复杂度
    
    functin a(){ //假设一句语句执行一次时间为1
        var i = 1;   //复杂度 1
        for(....){   //复杂度 n， 两行语句一共就2n
            for(){}  //复杂度 n^2 ==> n2
        }
    }
    如果n很大，那么常数项（1）和低阶项（n）就可以忽略不计，所以上述
    算法复杂度为O(n2)
        
#### 114.反转单向链表
    var reverseList = function(head){
        if(!head || !head.next)return head
        let pre = null, current = head, next;
        while(current){
            next = current.next
            current.next = pre
            pre = current
            current = next
        }
        
        return pre
    }
    
#### 115.typeof类型判断
    基本类型数据，除了null，其他都正确，
    typeof null ==> object
    
    引用类型除了function都显示object
     typeof function ==> function
     
    判断对象类型可以考虑使用instanceof
    
    但是基本类型数据使用instanceof判断需要通过new生成的才行
    
    var a = 'dfsd'; a instanceof String  //false
    var b = new String('sdsdas'); b instanceof String // true
    
#### 116.fn.bind().bind(a)
    以上可以转换为
    (function(){
        return function({
            return fn.call()
        }.call(a)
    })()
    
    最后绑定的是window，所以只看最左侧的bind
    
#### 117.== 的类型转换
    == 对比x和y时，有以下流程
    1.先判断是否类型相同，相同则比较大小
    2.类型不同，进行类型转换
    3.先判断是否在对比null和undefined，是就返回true
    4.判断是否为number和string类型，转换为number来比较
    5.其中一方为boolean，转换为number来比较，true=>1
    6.一方为对象且另一方为string，number，symbol，转换为原始类型 {} => '[object Object]',再判断
    
    数字与非数字型字符串比较 1 > 'abc' 字符串转化为数字，因为abc转化数字为NaN,所以永远是false
    
    数字型字符串比较 '222' > '33' 这种比较为ASCII码比较，依次取每个字符，字符转
    为ASCII码进行比较，ASCII码先大的即为大；因为第一个字符3比2大所以后面就不用考虑了；
    
    对象与数字比较,对象先转换为字符串,再转换为数字
        数组：先转['a','a']=>'a,a' []=>''
        对象和Function则转为字符串，再转为数字时为NaN，所以怎么比较都是false
    
#### 118.浅拷贝和深拷贝
    浅拷贝
        object.assign 和 展开运算符...
        
    深拷贝
        JSON.parse(JSON.stringify())
        
        有局限性，
            undefined、symbol、函数不能使用
            
#### 119.暂时性死区
    var tmp = 123;
    if (true) {
       tmp = 'abc'; // ReferenceError
       let tmp;
    }
    
    这里报错的原因是 let 不能变量提升，let会绑定整个块级作用域
    ES6规定，如果区块中存在let和const命令，这个区块对这些命令声
    明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用
    这些变量，就会报错。
    总之，在代码块内，使用let命令声明变量之前，该变量都是不可
    用的。这在语法上，称为“暂时性死区”
    
    这就是var会变量提升，let、const不会的原因
    
#### 120.模块化的好处
    1.解决命名冲突
    2.提供复用性
    3.提高可维护性
    
#### 121.进程和线程的区别
    js是单线程执行，
    进程描述了cpu在运行指令及加载和保存上下文所需的时间，
    放在应用上来说就代表一个程序
    线程是进程中的更小单位，描述了执行一段指令所需要的时间
    
#### 122.执行栈
    执行栈就是一个存储函数调用的栈结构，遵循先进后出的原则
    
    栈可存放的函数数量是有限制的，递归执行函数时，如果数量
    过多且未得到释放，就会出现爆栈的问题
    
    function bar(){
        bar()
    }
    
#### 123.event loop顺序
    微任务
        process.nextTick
        promise
        object.observe
        
    宏任务
        script
        setTimeout
        setInterval
        I/O
        UI rendering
        
    1.执行同步代码，宏任务
    2.执行栈为空，查询是否有微任务
    3.执行所有微任务
    4.必要的话渲染ui
    5.然后开始下一轮
    
#### 124.浏览器缓存的位置
    缓存的位置有四种
        1. Service Worker
            service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们
            ⾃由控制缓存 哪些⽂件、如何匹配缓存、如何读取缓存，并且缓存是持续
            性的。 当 Service Worker 没有命中缓存的时候，我们需要去调⽤ fetch
            函数获取数据。也 就是说，如果我们没有在 Service Worker 命中缓存的
            话，会根据缓存查找优先级去查 找数据。但是不管我们是从 Memory Cache
            中还是从⽹络请求中获取的数据，浏览器都 会显示我们是从 Service Worker 
            中获取的内容
            
            Service Worker 是运⾏在浏览器背后的独⽴线程，⼀般可以⽤来实现缓存功能。使⽤
            Service Worker 的话，传输协议必须为 HTTPS 。因为 Service Worker 中涉及到请 
            求拦截，所以必须使⽤ HTTPS 协议来保障安全
            
            Service Worker 实现缓存功能⼀般分为三个步骤：⾸先需要先注册 Service
            Worker ，然后监听到 install 事件以后就可以缓存需要的⽂件，那么在下次
            ⽤户访问 的时候就可以通过拦截请求的⽅式查询是否存在缓存，存在缓存的话
            就可以直接读取缓存 ⽂件，否则就去请求数据。以下是这个步骤的实现：
            
            // index.js
            if (navigator.serviceWorker) {
                 navigator.serviceWorker
                 .register('sw.js')
                 .then(function(registration) {
                    console.log('service worker 注册成功')
                 })
                 .catch(function(err) {
                    console.log('servcie worker 注册失败')
                 }) 
            }
            // sw.js
            // 监听 `install` 事件，回调中缓存所需⽂件
            self.addEventListener('install', e => {
                 e.waitUntil(
                    caches.open('my-cache').then(function(cache) {
                     return cache.addAll(['./index.html', './index.js'])
                    })
                 ) 
            })
            
            // 拦截所有请求事件
            // 如果缓存中已经有请求的数据就直接⽤缓存，否则去请求数据
            self.addEventListener('fetch', e => {
                 e.respondWith(
                     caches.match(e.request).then(function(response) {
                         if (response) {
                            return response
                         }
                        console.log('fetch source')
                     })
                 ) 
            })
             
             打开⻚⾯，可以在开发者⼯具中的 Application 看到 Service Worker 已 经启动了
             在 Cache 中也可以发现我们所需的⽂件已被缓存 
             当我们重新刷新⻚⾯可以发现我们缓存的数据是从 Service Worker 中读取的
        
        Workbox     
            service Worker写的比较复杂，有现成封装好的工具 Workbox
            
            首先在sw.js引入workbox官方js
                importScripts('workbox.js')  //importScripts是webworker引入js文件的方法
                
                引入后会全局挂载workbox实例
                
                if(workbox){
                    ...
                }else{
                    ....
                }
                
                使用api之前提前配置
                workbox.setConfig({})
                
                也可以指定存储时cache的名称
                workbox.core.setCacheNameDetails({
                    prefix:'edu-cms',
                    suffix:'v1'
                })
             
        2. Memory Cache
            Memory Cache 内存中的缓存，读取内存中的数据肯定⽐磁盘快。但是内存缓存虽
            然读取⾼效，可是缓存持续性很短，会随着进程的释放⽽释放。 
            ⼀旦我们关闭 Tab ⻚ ⾯，内存中的缓存也就被释放了。 
            当我们访问过⻚⾯以后，再次刷新⻚⾯，可以发现很多数据都来⾃于内存缓存
            
            那么既然内存缓存这么⾼效，我们是不是能让数据都存放在内存中呢？ 
                这是不可能的。⾸先内存容量小，用于存储大量数据不现实
                对于⼤⽂件来说，⽂件优先存储进硬盘
            
        3. Disk Cache
            Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，
            在所有浏览器缓存中， Disk Cache 覆盖⾯基本是最⼤的。它会根据 ·HTTP Herder· 中的
            字段判断哪些资源需要缓存，哪些资源可以不请求直接使⽤，哪些资源已经过期需要重新
            请求。并且即使在跨站点的情况下，相同地址的资源⼀旦被硬盘缓存下来，就不会再次去
            请求数据
            
        4. Push Cache
            push Cache是http/2中的内容，当以上缓存都没有命中才会使用，缓存时间很短，只在
            会话(session)中存在，会话结束就释放
            
#### 125.浏览器渲染原理
    所有的文件是通过字节形式传输的，接收到字节数据后，
    将字节数据转换为字符串，即代码，然后通过 词法分析
    转为标记（token），这个过程叫标记化。结束标记化后，
    这些标记紧接着转换为Node(节点对象)，根据Node的联系
    构建成一颗DOM树
    
    cssom树也是类似的过程，
    
    两者生成结合之后就成渲染树
            
#### 126.为什么操作DOM性能很差
    因为DOM是属于渲染引擎的，JS属于JS引擎，通过js操作DOM,
    就是涉及了两个线程的通信，势必带来性能上的损耗。
    而且操作DOM可能会出现重排重绘的情况，这也会带来导致性
    能上的问题
    
#### 127. 插入几万个DOM,如何实现页面不卡顿
    1.分批次插入渲染DOM, 通过requestAnimationFrame的方式循环
    插入DOM
    
    如何停止requestAnimationFrame?
        cancelAnimationFrame()接收一个参数 requestAnimationFrame默
        认返回一个id，cancelAnimationFrame只需要传入这个id就可以停止了。
        
    2.虚拟滚动
        这种技术原理是只渲染可视区域，非可见区域就不渲染
        
        <div style="overflow-y: scroll; height: 300px;" @scroll="handleScroll">
            <div v-for="item in items" :key="`${item.id}`">
                <slot :data="item">
                </slot>
            </div>
        </div>
        
#### 128.script加上async defer属性后
    两者都会并行下载，不会影响页面的解析
    defer 会按照顺序在 DOMContentLoaded 前按照页面出现顺序依次执行。
    async 则是下载完立即执行，适合不依赖其他脚本的js文件
    
#### 129.优化webpack
    针对两点优化：
        减少webpack打包时间
        让webpack打的包更小
        
        1.优化loader
            优化loader的搜索范围
                {
                    test:/\.js$/,
                    //开启缓存，只编译更改过的文件
                    loader:'babel-loader?cacheDirectory=true', 
                    include:[resolve('src')],
                    //依赖包都是编译过的，无需再编译
                    exclude:/node_modules/ 
                }
        
        2.HappyPack
            node是单线程，webpack打包也是单线程
            HappyPack可以将Loader同步转并行，提高打包效率
            
            module: {
                 loaders: [
                    {
                        test: /\.js$/,
                        include: [resolve('src')],
                        exclude: /node_modules/,
                        // id 后⾯的内容对应下⾯
                        loader: 'happypack/loader?id=happybabel'
                    }
                ] 
            },
            plugins: [
                new HappyPack({
                    id: 'happybabel',
                    loaders: ['babel-loader?cacheDirectory'],
                    // 开启 4 个线程
                    threads: 4
                }) 
            ]
        
        3.DllPlugin
            将特定库提前打包引入，极大减少打包类库的次数
            只有当类库更新版本才有需要重新打包，并且
            也可将公共代码抽离成单独文件的优化方案
            
            在项目根目录创建一个dll.config.js文件，配置需要抽取的第三方js，
            只是一个普通的js文件，可以修改成你想要的名字
            
            module.exports = {
              library: {
                vue: ["vue", "vue-router", "vuex"],
                others: ["axios", "js-cookie", "blueimp-md5"],
                dplayer: ["dplayer"],
                cos: ["cos-js-sdk-v5"],
                vod: ["vod-js-sdk-v6"],
                distpicker: ["v-distpicker"]
              }
            }
            
            
            const path = require("path");
            const webpack = require("webpack");
            const { CleanWebpackPlugin } = require("clean-webpack-plugin");
            const { library } = require("./dll.config.js");
            
            module.exports = {
              // 入口文件
              entry: {
                ...library
              },
              // 输出文件
              output: {
                path: path.join(__dirname, dllPath),
                filename: "MyDll.[name].js",
                library: "[name]_[hash]"
              },
              plugins: [
                // 清除之前的dll文件
                new CleanWebpackPlugin(),
                new webpack.DllPlugin({
                  path: path.join(__dirname, 'dist', "[name]-manifest.json"),
                  name: "[name]_[hash]"
                })
              ]
            }
            
            使用 clean-webpack-plugin 清除之前冗余的dll文件
            npm install --save-dev clean-webpack-plugin
            
        执行上面文件会打包出mainfest.json文件,配置文件引入    
            // webpack.conf.js
            module.exports = {
                // ...省略其他配置
                plugins: [
                     new webpack.DllReferencePlugin({
                         context: __dirname,
                         // manifest 就是之前打包出来的 json ⽂件
                         manifest: require('./dist/vendor-manifest.json'),
                     })
                 ] 
            }
            
        4.webpack-parallel-uglify-plugin
            UglifyJs用来压缩js文件，但是是单线程的
            webpack-parallel-uglify-plugin可以并行
            uglifyjs插件，提高效率
            
            webpack4只要开启production模式就会默认开启
            
        5.按需加载，路由懒加载可以减少打包体积
        
        6.tree shaking
            这个插件可以删除未使用的代码
            webpack4中生产环境会自动启动这个功能
            
#### 130. 前端路由原理
    通过监听url的变化，匹配路由规则，显示相应的页面，并且无需刷新
    有两种方式
        hash模式，修改url后面的hash值不会引起页面刷新，通过
        监听hashchange来获取相应hash值，然后触发页面变化
        兼容性比较好，无需后端配置
        
        history模式，利用h5新api，history.pushState，replaceState
        新增历史记录和替换历史记录，不会引起页面刷新，但是兼容性没
        hash模式好，而且后台需要配置其他路径都指向index.html文件
        
#### 131.computed和watch区别
    computed是计算属性，依赖其他属性，并且computed的值有缓存，要
    计算的值有变化才会返回内容，一般需要动态获取值时使用
    
    watch是监听对应的值有变化才会执行回调，一般处理值变化后的
    复杂逻辑
    
#### 132.nextTick原理
    nextTick用于满足更新DOM后获取最新的DOM,即渲染后的操作
    this.$nextTick(()=>{
        渲染后执行的回调
    })
    
    每次事件循环的最后都会进行ui render，就是更新DOM，需要
    在渲染后执行，就需要等主线程任务执行完才执行，即将回调
    放入微任务队列，vue是使用promise来将回调放入微任务，但是
    promise兼容性不是非常好，通过降级处理，使用宏任务的setImmdiate,
    如果不能使用就MessageChannel，都不行就使用setTimeout
    
#### 133.UDP与TCP的区别是什么
    UDP
        1.面向无连接
            在传输之前不需要像TCP一样需要进行三次握手，想发数据
            就可以直接发，不对数据做任何拆分和拼接处理
        2.不可靠性
            由于无连接，发送数据随意，不关心对方是否正确接收，所以可靠性低
            UDP没有堵塞说法，以恒定速率发送，无关网络条件，容易发生丢包
            但是优点明显，在实时性要求高的场景比较适用
        3.高效
            由于连接要求不高，所有没那么复杂，而且头部开销小，只有八字节
            相比tcp的至少二十字节要少得多，传输数据报文时很高效
        4.传输方式
            支持一对一，一对多，多对多，多对一的方式
        5.适合场景
            直播，游戏，视频会议等实时性要求高的场景
            
    TCP
        1.需要进行三次握手来建立连接
        2.头部比UDP复杂
        3.严格控制有序传输，保证数据可靠性
        4.高效性跟UDP比就没那么高效
        
    ARQ
        ARQ协议也就是超时重传机制。
        通过确认和超时机制保证了数据的正确送达，ARQ协议包含停止等待ARQ和
        连续ARQ两种协议
        sss
#### 134.TLS
    https还是通过http传输，只是通过TLS加密了
    TLS位于传输层，使用了两种加密技术，对称加密和非对称加密
    
    对称密钥就是两边拥有相同密钥，缺点是密钥在传输过程有可能被截获
    非对称密钥就是分为公钥密钥，公钥加密，私钥解密
    
    TLS握手过程：
        1.客户端发送一个随机值以及需要的协议和加密方式
        2.服务端接收后返回一个随机值，协议和加密方式，还有证书
        3.客户端接收后验证证书，验证通过后生成一个随机值，并且用服务器证书的
        公钥加密后发送给服务端，如果服务端需要证书的话，客户端也会发送证书
        4.服务端用私钥解密返回的随机值，这时候两端都有这三个随机值，通过
        约定的加密方式生成密钥，接下来的通信使用该密钥加密解密
        5.因为非对称加密的方式通信比较耗性能，所以后面的通信将会以对称加密的方式
        通信
        
#### 135.位运算
    1. 左移 << 二进制左移一位，把左移看成以下 公式 a * (2 ^ b)
    2. 右移 >> 看成以下公式 int v = a / (2 ^ b)
    3.按位运算
        3.1 按位与 每⼀位都为 1，结果才为 1
            8 & 7 // -> 0
            // 1000 & 0111 -> 0000 ->
        3.2 按位或 其中⼀位为 1 ，结果就是 1 
            8 | 7 // -> 15
            // 1000 | 0111 -> 1111 -> 15
        3.3 按位异或 每⼀位都不同，结果才为 1
            8 ^ 7 // -> 15
            8 ^ 8 // -> 0
            // 1000 ^ 0111 -> 1111 -> 15
            // 1000 ^ 1000 -> 0000 -> 0
            从以上代码中可以发现按位异或就是不进位加法 
            
    ⾯试题：两个数不使⽤四则运算得出和
            这道题中可以按位异或，因为按位异或就是不进位加法， 8 ^ 8 = 0 如果进
            位了，就是 16 了，所以我们只需要将两个数进⾏异或操作，然后进位。那
            么也就是说两个⼆进制都是 1 的位置，左边应该有⼀个进位 1 ，所以可以 
            得出以下公式 a + b = (a ^ b) + ((a & b) << 1) ，然后通过迭代的⽅式 模拟加法
            
            function sum(a, b) {
                 if (a == 0) return b
                 if (b == 0) return a
                 let newA = a ^ b
                 let newB = (a & b) << 1
                 return sum(newA, newB) 
            }
            
#### 136.vue为什么采用vdom？
    1.性能受场景的影响是非常大的，vue使用vdom在性能方面的考量不是最主要的
    2.vdom可以解耦html依赖，不再依赖html解析器，编译时时可以提高运行时效率，
    压缩运行时体积
    3.可以渲染到DOM以外的平台，这是现代框架的高级特性
    
#### 137.如何监听vue子组件生命周期
    父组件
        <aaa @hook:mounted = "dosomething" />
        
        dosomething(){
            console.log('子组件mounted钩子触发')
        }
        
    或者
        <aaa @dosomething = "dosomething" />
        
        子组件
            mounted(){
                this.$emit('dosomething')
            }

#### 138.es6的新特性
    1.块级作用域，let，const声明
    2.箭头函数
    3. ... 扩展运算符
    4.解构赋值
    5.模块化的引入，import， export default
    6.class类的引入
    7.promise
    8.新增数据类型，symbol，set，Map
    9.api的增加
        数组的Array.from, Array.of,Array.fill(Array.of替代Array(),new Array(2)单数值传入问题)
        object.assign浅拷贝
        string的startsWith，endsWith
        Number.isInteger
    10.模板字符串，方便字符串的拼接
    
#### 139.小程序页面生命周期和组件生命周期
    page
          onLoad 页面创建时执行
          onShow: 页面出现在前台时执行
          onReady: 页面首次渲染完毕时执行
          onHide: 页面从前台变为后台时执行
          onUnload: 页面销毁时执行
          onPullDownRefresh: 触发下拉刷新时执行
          onReachBottom: 页面触底时执行
          onShareAppMessage: 页面被用户分享时执行
          onPageScroll: 页面滚动时执行
          onResize: 页面尺寸变化时执行
          onTabItemTap  tab 点击时执行
          
          
    component
        created 在组件实例刚刚被创建时执行
        attached 在组件实例进入页面节点树时执行
        ready 在组件在视图层布局完成后执行
        moved 在组件实例被移动到节点树另一个位置时执行
        detached 在组件实例被从页面节点树移除时执行
        error 每当组件方法抛出错误时执行
        
        lifetimes: {
            attached: function() {
              // 在组件实例进入页面节点树时执行
            },
            detached: function() {
              // 在组件实例被从页面节点树移除时执行
            }
        }
        
        // 以下是旧式的定义
        attached: 。。。
        detached: 。。。
        
        
        组件所在页面的生命周期
            pageLifetimes: {
                show: function() {
                  // 页面被展示
                },
                hide: function() {
                  // 页面被隐藏
                },
                resize: function(size) {
                  // 页面尺寸变化
                }
            }


#### 140.正则的贪婪匹配和懒惰匹配
    在限定符后面加上?，则为懒惰模式；在限定符后面不加?，则为贪婪模式
    
    贪婪模式：会匹配最长的以开始位置开始，以结束位置结束的字符串；
    懒惰模式：匹配尽可能少的字符

#### 141.restful api
    restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。
    它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，
    更易于实现缓存等机制。
    
    RESTful的关键是定义可表示流程元素/资源的对象。在REST中，每一个对象都是通过URL来表示的，
    对象用户负责将状态信息打包进每一条消息内，以便对象的处理总是无状态的。
    
    REST 的基本原理包括：
        系统上的一切对象都要抽象为资源；
        每个资源对应唯一的资源标识（URI）；
        对资源的操作不能改变资源标识（URI）本身；
        所有的操作都是无状态的等等。
    
    
#### 142.框架选型
    1.框架自身 
        a.是否成熟 b.架构和模式 c.生态如何，社区活跃度怎么样  d.兼容性  e.案例多不多
        
    2.项目契合 
        a.是否能满足需求 b.是否适合项目 ， 比如需不需要seo，需要的话可以选择服务端渲染 vue ssr
        管理后台系统、h5网站、混合app，移动端还是pc端， 大型应用还是小型应用， 有没有跟框架配套的ui框架如何， 
        保证开发效率同时开发体验如何， 降低人力成本，就是前期开发成本降低和后期维护成本降低
        开发紧凑可以使用开发人员都熟悉的框架
        边缘项目可以考虑使用新技术
        
    jquery 有兼容性要求，交互比较少
    angular 版本差异性大，学习曲线比较陡，
    vue 国人开发的，简洁易理解，接口灵活，侵入性强
    react 性能优越，规范性强，也比较繁琐，学习成本比较高，但是跨平台的扩展性很强，react-native就是同生态的跨平台框架
        
#### 143.对框架的理解
    可以先说说为什么需要用框架，不用框架的话，直接写代码，随着版本的迭代，有可能出现各种变量污染，代码逻辑混乱，难以维护。
    框架可以有效规范代码的编写和存放，更好的组织代码，可维护性也更高，特别是多人开发的情况下，现在的主流框架都是提倡组件化
    组件化可以使每个人的工作有效解耦，而且框架一般会对一些繁琐的操作进行封装，这样避免了很多冗余代码，写起来比较简便简洁。
    
#### 144.遇到过什么兼容性问题
    1.默认的margin，padding各浏览器有差异，使用*{ margin :0; padding: 0};reset.css
    2.
    
#### 145.移动端ui框架
    mint-ui，iview，mui
    
#### 146.Vue的双向数据绑定原理是什么？
    答：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，
        getter，在数据变动时发布消息给订阅者，触发相应的监听回调。
        
    具体步骤：
    
        第一步：需要observe的数据对象进行递归遍历，包括子属性对象的属性，劫持其属性后，就能监听到了数据变化
        
        第二步：compiler编译器解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节
                点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
        
        第三步：Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是:
                1、在自身实例化时往属性订阅器(dep)里面添加自己
                2、自身必须有一个update()方法
                3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。
        
        第四步：MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，
                通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视
                图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。
        
#### 147.描述下 vue 从初始化页面--修改数据--刷新页面 UI 的过程？
      初始化阶段，一方面，Vue的数据监听器遍历data属性和子对象属性，通过object.defineProperty劫持属性，监听数据变化；
      另一方面指令编译器Compiler对模板的元素节点的变量和指令进行解析，初始化视图，并订阅Watcher来更新试图。
      watcher会将自己添加到消息订阅器Dep, 只有属性一变化就会通知watcher，初始化完毕。
      当数据发生变化时，监听器触发相应属性的setter，遍历消息订阅器，调用其更新方法，vue内部通过diff算法，
      patch相应的更新完成对订阅者视图的改变
      
#### 148.如何理解vue的响应系统
    1.任何一个 Vue Component 都有一个与之对应的 Watcher 实例
    2.Vue 的 data 上的属性会被添加 getter 和 setter 属性
    3.当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)
    4.data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新
    
#### 149.既然 Vue 通过数据劫持可以精准探测数据变化,为什么还需要虚拟 DOM 进行 diff 检测差异?
    现代前端框架有两种方式侦测变化，一种是pull，一种是push
    
    pull: 其代表为React，我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom
    Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，
    然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。
    
    push: Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，
    一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但
    是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher，
    一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会
    无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套
    响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加
    具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。
    
#### 150.组件中写 name 选项有什么作用？
    1.项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤
    2.DOM 做递归组件时需要调用自身 name
    3.vue-devtools 调试工具里显示的组见名称是由vue中组件name决定的
    
#### 151.vue怎么重置data
    this.$options.data(this)获取初始的data对象
    
    object.assign(this.$data, this.$options.data(this))
    
#### 152.说一下 Vue 和 React 的认识，做一个简单的对比
    1.监听数据变化的实现原理不同
        vue是通过劫持属性，通过diff找出精确的变化点，不需要重新渲染整个组件树
        react通过引用比较方式进行，子组件需要通过shouldComponentUpdate来优化，不然没必要重新渲染的组件会重复渲染
        
    2.数据流
        vue是双向数据流，react是单向数据流
    3.模板渲染方式的不同
        vue通过一种拓展的html语法来渲染
        react是通过jsx渲染
        
#### 153.vue 首屏加载优化
    1.把一些不会经常修改的第三方库在index.html中通过cdn引入
    
    然后找到 build/webpack.base.conf.js 文件，在 module.exports = { } 中添加以下代码
    
    externals: {
      'vue': 'Vue',
      'vue-router': 'VueRouter',
      'element-ui': 'ELEMENT',
    },
    这样 webpack 就不会把 vue.js, vue-router, element-ui 库打包了。
    
    2.组件不全局引入
    
    3.生产环境不生成map文件，屏蔽sourceMap
    
    4. 开启gzip压缩
      这个优化是两方面的，前端将文件打包成.gz文件，然后通过nginx的配置，让浏览器直接解析.gz文件。
      compression-webpack-plugin
      
    5. 首页单独做服务端渲染
    
    6.开启gzip压缩
        
    7.类名不能太长，且选择器不能太长，一般不能超过三级
    
    8.babel-plugin-transform-runtime
        "plugins": [
            "transform-runtime"
        ]
        清除Babel产生的冗余辅助函数
    
    9.ExtractTextPlugin提取css到单独文件，CommonChunkPlugin提取公共模块
    
    10.HappyPack并行执行loader，webpack-parallel-uglify-plugin并行执行js压缩
    
#### 154.less
    变量 @boxwidth:100px;
    嵌套
    混合 .b{}
         .a{ .b()}
    转义：直接输出字符串，不做改变
        @min768: ~"(min-width: 768px)";
        媒体查询
          @media @min768 {}
        
        编译为：
          @media (min-width: 768px) {}
        注意，从 Less 3.5 开始，可以简写为：
        
        @min768: (min-width: 768px);
    函数 less内置很多函数，
    映射
        #a(){bgC:red} 
        .b{background-color:#a[bgc]}
        相当于生成了一个类
    作用域 @var:xxx
    
#### 155.typescript
    强类型语言
    
    优点：
        1. 静态类型检查
            避免了很多调试才会出现的问题
        2. ide提示
        3. 代码重构
        4. 可读性
        5. 代码健壮性
        
    数据类型
      let a:boolean = false
      布尔值，number，string，void，null，undefined
      undefined 和 null 是所有类型的子类型
      
      any任意值，可以被赋值为任意类型
      可以访问任意值的任何属性和方法
      声明一个变量为任意值之后，对它的任何操作，
      返回的内容的类型都是任意值。
      
      未指定类型的变量识别为任意类型或者根据类型推论定义
      
    联合类型 string|number
    断言 as，一般用于联合类型的数据
    接口interface 对象的类型
    数组类型 number[] 
    
    声明文件
        声明文件必需以 .d.ts 为后缀
        声明全局变量，所有ts文件都能引用
        
    type 类型别名，相当于自定义类型，值为定义的字符串
    元组  let tom: [string, number] = ['Tom', 25];  
    枚举 enum Days {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
    类与接口 
        interface Alarm{}
        class A implements Alarm,xxxx{}
        
        接口之间可以继承
        interface Blarm extends Alarm{}
        
        类会自动生成该类的类型，所以接口可以继承类
        interface XX extends A
    泛型 <T> 表示任意输入值，不确定可以等到调用时
        再确定类型
        
#### 156.移动端适配 postcss-pxtorem + lib-flexible
    postcss是一个工具，拥有很多插件，他会将css解析为AST，
    然后经过各种插件进行处理
    相当于js的babel
    
    amfe-flexible(lib-flexible改进后)
        npm i -S amfe-flexible
        动态计算html的font-size配合rem来适配不同尺寸的移动端设备
        
    1.Autoprefixer
        自动添加各个属性浏览器前缀
    2.postcss-autoreset
        重置初始属性
    3.cssnano
        css代码压缩
    4.postcss-pxtorem
        把px按设置rem值转换为rem
        
#### 157.vue-property-decorator
    vue的装饰符
    @Component (完全继承于vue-class-component)
    @Emit
    @Prop
    @Watch
    
#### 158.$on原理
    在vue内部初始化时会为每个组件实例挂载一个this._events私有的空对象属性：
        vm._events = Object.create(null) // 没有__proto__属性
    这个里面存放的就是当前实例上的自定义事件集合，也就是自定义事件中心，
    它存放着当前组件所有的自定义事件。和自定义事件相关的API分为以下四个：
    this.$on、this.$emit、this.$off、this.$once，它们会往这个事件中心中
    添加、触发、移除对应的自定义事件
    
#### 159.垃圾回收机制
    JavaScript 中的内存管理是自动执行的，而且是不可见的。
    凡是无法访问的值都会被回收
    如果引用或引用链可以从根访问任何其他值，则认为该值是可访问的
    根一般指全局变量，嵌套的调用链，比如闭包
    
    基本的垃圾回收算法称为“标记-清除”，定期执行以下“垃圾回收”步骤:
        1.垃圾回收器获取根并“标记”(记住)它们。
        2.然后它访问并“标记”所有来自它们的引用。
        3.然后它访问标记的对象并标记它们的引用。所有被访问的对象都被记住，
          以便以后不再访问同一个对象两次。
        4.以此类推，直到有未访问的引用(可以从根访问)为止。
        5.除标记的对象外，所有对象都被删除。
    
    JavaScript引擎应用了许多优化，使其运行得更快，并且不影响执行，一些优化:
        1.分代回收——对象分为两组:“新对象”和“旧对象”。许多对象出现，完成它们的工作并迅速结
        束，它们很快就会被清理干净。那些活得足够久的对象，会变“老”，并且很少接受检查。
        2.增量回收——如果有很多对象，并且我们试图一次遍历并标记整个对象集，那么可能会
        花费一些时间，并在执行中会有一定的延迟。因此，引擎试图将垃圾回收分解为多个部
        分。然后，各个部分分别执行。这需要额外的标记来跟踪变化，这样有很多微小的延迟，
        而不是很大的延迟。
        3.空闲时间收集——垃圾回收器只在 CPU 空闲时运行，以减少对执行的可能影响。
    
    
    怎么观察内存泄漏？
        1.打开谷歌开发者工具，选择 performance 面板
        2.在顶部的Capture字段里面勾选 Memory
        3.点击左上角的录制按钮。
        4。在页面上进行各种操作，模拟用户的使用情况。
        5.一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。  
        
        如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之，就是内存泄漏了。
#### 160.vue父子组件生命周期顺序
    一、加载渲染过程
    父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
    二、子组件更新过程
    父beforeUpdate->子beforeUpdate->子updated->父updated
    三、父组件更新过程
    父beforeUpdate->父updated
    四、销毁过程
    父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
    标签: vue, vue生命周期
    
#### 161.babel-runtime，babel-transform，babel-polyfill
    Babel默认只转换新的JavaScript语法，而不转换新的API。 
    例如Generator、Set、Proxy、Promise 等全局对象，以及一
    些全局对象上的方法（比如 Object.assign）都不会转译。
    
    babel-polyfill用来转译这些api，但是会存在污染全局环境
    babel-runtime
        babel-polyfill解决了Babel不转换新API的问题，但是直接在代码中插入帮助函数，
        会导致污染了全局环境，并且不同的代码文件中包含重复的代码，导致编译后的代
        码体积变大
        Babel为了解决这个问题，提供了单独的包babel-runtime用以提供编译模块的工具函数， 启用插件babel-plugin-transform-runtime后，Babel就会自动使用babel-runtime下的工具函数，
        
    Babel原理：babel是对语言进行转译，把同种语言的高版本规则翻译成低版本规则，对语言进行解析
               转换为ast语法树，根据所需规则对AST树进行遍历转译，得到新的AST树，用babel-generator通
               过AST树生成相应代码
               
#### 162.抽象语法树AST
    AST相当于js的最底层的东西了，
    拆解工具recast，可以做拆解，遍历修改，读取文件
    把语言拆解成AST对象，拆解成最基础Identifier（标志）对象为止，相当于一个身份，
    这个标志对象拥有各种属性来表示其身份，然后通过遍历这些对象对其进行修改，然后再
    将新的AST树转换成相应的语言，就完成了转译
    
#### 163.动态加载组件
    import() 异步加载组件，运行时加载
    <component :is="导出组件的方法名"></component>
    
#### 164.私有属性怎么写
    es6和es5都只能通过闭包实现
    
#### 165.axios原理
    基于ajax
    
#### 166.如何打包类库
    有些库可以通过各种方式引入，cmd，amd，es6都可以
    因为他们打包规范使用UMD
    
    可以通过
    webpack 的
        output: {
          library: "myDemo"，
          libraryTarget: 'UMD'
        }
        
    output.library
        支持输入string或者object(从 webpack 3.1.0 版本开始支持; 限于 libraryTarget: “umd” 时使用)类型的值。
        output.library的值被如何使用会根据output.libraryTarget的取值不同而不同。而默认output.libraryTarget的取值是var， 即导出值将回分配到 通过var声明的变量 myDemo上。
        
    output.libraryTarget
        libraryTarget: "var"- (default)
            使用这个配置，当库被加载时，那么库的返回值会被分配到使用用var申明的变量上。
            如果没有设置library则不会发生赋值行为
        
        libraryTarget: "assign"
            会把库返回值分配给一个没使用var申明的变量中， myDemo = _entry_return_
            
    通过对象属性暴露
        
        libraryTarget: "this",当前作用域的this
        libraryTarget: "window" 挂到window对象
        libraryTarget: "global" 挂到global对象
        
        libraryTarget: "commonjs" - 将库的返回值分配给exports对象的由output.library指定的属性。
            exports["myDemo"] = _entry_return_;
            require("myDemo").doSomething();
            
        libraryTarget: "commonjs2" - 将库的返回值分配给module.exports。
            module.exports = _entry_return_;
            const myDemo = require("myDemo");
            myDemo();
        libraryTarget: "amd" - 这个选项会把库作为 AMD 模块导出。
        libraryTarget: "umd" -这个选项会尝试把库暴露给前使用的模块定义系统，
                        这使其和CommonJS、AMD兼容或者暴露为全局变量。
                        output.library 选项在这里是必须的。
                        
    output: {
        library: {
          root: "myDemo",
          amd: "my-demo",
          commonjs: "my-common-demo"
        },
        libraryTarget: "umd"
    }
    
#### 167.修改scoped里的样式
    在scoped作用域中修改第三方默认样式无法修改，有以下方法
    1.scoped穿透
        <style scoped>
            外层 >>> 第三方组件 {
                样式
            }
        </style>
    2.使用两个style
        <style></style>
        <style scoped></style>
    3.使用/deep/，某些预处理器（如Sass）可能无法>>>正确解析，可以使用/deep/
        <style scoped lang="scss">
        　　.form {
        　　　　background-color: #fff;
        　　　　/deep/ .list{
        　　　　　　font-size: 18px;
        　　　　}
        　　}
        </style>
        
#### 168.v-model和vuex合用
    <input v-model="message" />
    
    computed:{
        message:{
            get(){
                return message
            },
            set(val){
                this.$store.dispatch()
            }
        }
    }
    
    或者
    
    <input :value="message" @input="updateMessage">
    
    computed: {
      ...mapState({
        message: state => state.obj.message
      })
    },
    methods: {
      updateMessage (e) {
        this.$store.commit('updateMessage', e.target.value)
      }
    }
    
#### 169.mapState，mapActions, mapMutations
    mapState其实就是一个语法糖，返回一个对象
    mapState({
        count: 'count', // 第一种写法
        sex: (state) => state.sex, // 第二种写法
        from: function (state) { // 用普通函数this指向vue实例,要注意
          return this.str + ':' + state.from
        }
    })
    
    computed:{
        ...mapState({count:(state)=>state.sex})
    }
    
    mapMutations和mapActions
    
        methods:{
            ...mapMutations(['addFn']) => 表示将this.addFn方法映射为this.$store.commit("addFn"),
            ...mapActions(['addFn']) => this.$store.dispatch('addfn')
            或者
            ...mapActions({
                addFn:'addfn'
            })
        }
        
        要传参的时候，直接调用this.addFn(1) => this.$store.dispatch('addFn',1)
        
    actios重名会全部执行，可以使用命名空间namespace避免
    
    在模块的store文件中
        export default {
            namespace:ture,
            state,
            mutations
        }
        
        使用的时候
        ..mapActions({
            addFn:'callys/addFn' //前面为模块名
        })
    
#### 170.断点续传
    <input type="file" id="file" onchange="fileInfo()">
    var fileObj = document.getElementById('file').files[0];获取文件对象
    
    注意：我们获取的文件对象是可以使用slice方法的，这是断点续传重要的方法
    
    // 文件切块大小为1MB
    const chunkSize = 1024 * 1024;
    
    // 从start字节处开始上传
    function upload(start) {
        let fileObj = document.getElementById('file').files[0];
        // 上传完成
        if (start >= fileObj.size) {
            return;
        }
        // 获取文件块的终止字节
        let end = (start + chunkSize > fileObj.size) ? fileObj.size : (start + chunkSize);
        // 将文件切块上传
        let fd = new FormData();
        fd.append('file', fileObj.slice(start, end));
        // POST表单数据
        let xhr = new XMLHttpRequest();
        xhr.open('post', 'upload.php', true);
        xhr.onload = function() {
            if (this.readyState == 4 && this.status == 200) {
                // 上传一块完成后修改进度条信息，然后上传下一块
                let progress = document.getElementById('progress');
                progress.max = fileObj.size;
                progress.value = end;
                upload(end);
            }
        }
        xhr.send(fd);
    }
    
#### 171.forEach、map的区别
    forEach没有返回值，
    map有返回值
    
    一、相同点：
        1.都是循环遍历数组中的每一项
        2.每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）
        3.匿名函数中的this都是指向window
        4.只能遍历数组
    
    二、不同点
        1.map()会返回新，forEach()不会返回数据。
        2.forEach()允许callback更改原始数组的元素。map()返回新的数组。
        3.需要return值回去
        
        map(function(item,index,arr){},thisValue) thisValue表示传入的this，默认为window
        forEach一样的结构
        
        forEach通过return 来实现continue，可以通过throw来实现
        
#### 172.字符串与字符串比较
    会根据字符串的第一位的ascii码来比较
    str.charCodeAt()获取ascii码
    
    所以'12'>'9'为false
    
    
#### 173.const是保证指向地址不变，并非保证内容不变
    const a = {}
    a.tyo=1 不会报错
    
#### 174.块级作用域
    es5只有全局作用域和函数作用域
    es6新增了块级作用域，函数作用域也是属于块级作用域
    
    {}包起来就是块级作用域
    
    而es5 if(){var a = 1} console.log(a) //1 
    
    es6因为有块级作用域所以上面例子会报错
    
#### 175.解构赋值可以给默认值
    var [x,y='b'] = [1] //x=1,y='b'
    var [x,y='b'] = [1,2] //x=1,y=2
    var [x,y='b'] = [1,undefined] //x=1,y='b'
    var [x,y='b'] = [1,null] //x=1,y=null
    
    内部是使用===严格等于判读是否为undefined才确认是否使用默认值
    
    let [x = 1, y=x] = [2] //x=2,y=2
    let [x=y,y=1] = [1] //报错，因为y还没定义
    
    对象的解构赋值
    var {foo:baz} = {foo:'aaa'}
    baz = 'aaa'
    
    [x,y] = [y,x] //交换值
    
#### 176.判断数据类型
    最完美的解决方式
    object.prototype.toString.call() =>'[object string]'
    无论是null，error，date都可以准确判断
    
#### 177.keep-alive生效时，除了activated和deactivated还有什么生命周期会调用
    初始化时created、mounted和activated会触发，重新激活时只触发activated
#### 178.css优先级计算公式   
    !important 无限大
    行内样式 1000
    id 100
    类选择器、属性选择器或伪类 10
    标签和伪元素 1
    *通配符 0
#### 179.盒子模型
    盒子模型分标准盒模型和ie盒模型
    标准盒模型包括content、padding、border、margin，且content不包含其他部分
    ie盒模型也是content、padding、border、margin，但是content包含padding和border
    所以IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。
    
    内联盒模型
        内容区域：指的content
        内联盒子：让内容排成一行，该盒子又可以细分为“内联盒子”和“匿名内联盒子”。
        行框盒子：每一行就是一个行框盒子，每个行框盒子都是由一个个内联盒子组成，注意：line-height是作用在行框盒子上的
        包含盒子：此盒子由一行一行的“行框盒子”组成
        
    padding的百分比的宽高都是相对于width的
    
    兼容性做法：建议不要给元素添加具有指定宽度的内边距，而是尝试将内边距或外边距添加到元素的父元素和子元素。
    
#### 180.http的特点
    1.支持客户/服务器模式。
    2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。
    由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。
    3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。
    4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，
    并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
    5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。
    缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次
    连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
    
#### 181.箭头函数和普通函数的区别
    1.箭头函数是匿名函数，不能作为构造函数，不能使用new
    2.箭头函数不绑定arguments，取而代之用rest参数...解决
    3.箭头函数不绑定this，会捕获其所在的上下文的this值，作为自己的this值
    4.箭头函数通过 call()或apply() 方法调用一个函数时，只传入了一个参数，对 this 并没有影响，无法改变this。
    5.箭头函数没有原型属性
    
#### 182.http和tcp的关系
     建立起一个TCP连接需要经过“三次握手”：
      第一次握手：客户端发送syn包(syn=j)(一种编号)到服务器，并进入SYN_SEND状态，等待服务器确认；
      
      第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
      
      第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。
      
      握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP连接一旦建立，在通信双方中的任何一方主动关闭连 接之前，TCP 连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开TCP连接的请求，断开过程需要经过“四次握手”（过程就不细写 了，就是服务器和客户端交互，最终确定断开）
      
      HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，也是手机联网常用的协议之一，HTTP协议是建立在TCP协议之上的一种应用。
      由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种“短连接”，要保持客户端程序的在线状态，需要不断地向服务器发起连接请求。
      
      简单的说，TCP就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。
      TCP是底层通讯协议，定义的是数据传输和连接方式的规范
      HTTP是应用层协议，定义的是传输数据的内容的规范
      
      HTTP支持的是www服务 
      而TCP/IP是协议 
      它是Internet国际互联网络的基础。TCP/IP是网络中使用的基本的通信协议。 
      TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如：远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不单单是TCP和IP。
      
      套接字（socket）概念
            套接字（socket）是通信的基石，是支持TCP/IP协议的网络通信的基本操作单元。
      它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：连接使用的协议，本地主机的IP地址，本地进程的协议端口，远地主机的IP地址，远地进程的协议端口。
      应用层通过传输层进行数据通信时，TCP会遇到同时为多个应用程序进程提供并发服务的问题。多个TCP连接或多个应用程序进程可能需要通过同一个 TCP协
      议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与TCP／IP协议交互提供了套接字(Socket)接口。应用层可以
      和传输层通过Socket接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。